include "../msp_mul.i.vad"
include "sub_mod.i.vad"

#verbatim

include "../msp_mul.i.dfy"
include "sub_mod.i.dfy"

module mont_mul_add {

import opened msp_machine
import opened msp_decls
import opened msp_vale
import opened mem
import opened stack
import opened integers

import opened bv16_mm_lemmas
import opened bv16_op_s

import opened msp_mul
import opened sub_mod
import opened msp_reg_save

#endverbatim

function mont_loop_inv(
    a:  uint16,
    d0: uint16,
    A: uint32_view_t,
    B: uint32_view_t,
    b: seq(uint16),
    n: seq(uint16),
    prev_c: seq(uint16),
    next_c: seq(uint16),
    j: nat): bool extern;

function mont_loop_inv_pre_lemma(
    a:  uint16, // a
    d0: uint16, //d0
    m0d: uint16, //d0inv
    A: uint32_view_t, // A
    B: uint32_view_t, // B
    b: seq(uint16), // b
    n: seq(uint16), // n
    c: seq(uint16)) : void extern;

function mont_loop_inv_peri_lemma(
    a:  uint16,
    d0: uint16,
    A: uint32_view_t,
    B: uint32_view_t,
    next_A: uint32_view_t,
    next_B: uint32_view_t,
    b: seq(uint16),
    n: seq(uint16),
    prev_c: seq(uint16),
    c: seq(uint16),
    next_c: seq(uint16),
    j: nat) : void extern;

function mont_loop_inv_post_lemma(
    a:  uint16,
    d0: uint16,
    A: uint32_view_t,
    B: uint32_view_t,
    b: seq(uint16),
    n: seq(uint16),
    prev_c: seq(uint16),
    c: seq(uint16),
    bout: uint1): void extern;

function mont_loop_cond_sub_lemma(
    a:  uint16,
    d0: uint16,
    b: seq(uint16),
    n: nat,
    prev_c: nat,
    c: seq(uint16),
    next_c: seq(uint16),
    bout: uint1,
    next_bout: uint1): void extern;

function montmul_inv(
    c: seq(uint16),
    a: seq(uint16),
    i: int,
    b: seq(uint16),
    rsa: rsa_params) : bool extern;

function montmul_inv_lemma(
    prev_c: seq(uint16),
    a: seq(uint16),
    x: seq(uint16),
    i: int,
    d0: int,
    b: seq(uint16),
    rsa: rsa_params): void extern;

function frames_top_diff(f1: frames_t, f2: frames_t): bool extern;

procedure mma_pre(
    ghost iter_c: iter_t,
    ghost a: uint16,
    ghost iter_b: iter_t,
    ghost iter_n: iter_t,
    ghost rsa: rsa_params)

    returns (
    ghost A: uint32_view_t,
    ghost B: uint32_view_t,
    ghost next_iter_b: iter_t,
    ghost next_iter_n: iter_t,
    ghost n_end: uint16)

    {:frame false}

    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 4);

        symbols?["n"];
        rsa.M0D == 0x71df;

        iter_c.base_ptr != iter_n.base_ptr;
        iter_c.base_ptr != iter_b.base_ptr;

        mvar_iter_inv(heap, iter_c, r12, 0, (-1));
        r13 == a;
        mvar_iter_inv(heap, iter_b, r14, 0, (-1));
        mvar_iter_inv(heap, iter_n, load_symbol(mem, "n"), 0, rsa.M);

        rsa_params_inv(rsa);

    ensures
        mem == old(mem).(frames := frames);

        read_top_frame(mem) == seq(n_end);
        frames_top_diff(old(mem).frames, mem.frames);

        sp == old(sp) - 2;

        // r4 == d0;
        r5 == a;
        mvar_iter_inv(heap, next_iter_b, r6, 1, (-1));
        mvar_iter_inv(heap, next_iter_n, r7, 1, rsa.M);
        mvar_iter_inv(heap, iter_c, r8, 0, (-1));
        r9 == A.uh;
        r10 == B.uh;
        n_end == 384 + iter_n.base_ptr;
        r15 == n_end;

        next_iter_b == b16_iter_load_next(iter_b, true);
        next_iter_n == b16_iter_load_next(iter_n, true);

        mont_loop_inv(a, r4, A, B,
            iter_b.buff, iter_n.buff, iter_c.buff, iter_c.buff, 1);
{
    push_frame(2);

    mov_w(r12, r8);
    mov_w(r13, r5);
    mov_w(r14, r6);

    let _ := lw_iter(r12, false, r14, iter_c);

    next_iter_b := lw_iter(r6, true, r13, iter_b);
    mov_w(r5, r12);

    A := mula16();

    // assert A.full = a * iter_b.buff[0] + iter_c.buff[0];
    mov_w(r12, r10); // r10 == lh(A)
    mov_w(r13, r9);  // r9  == uh(A)

    mov_w_imm(0x71df, r13);
    __mspabi_mpyi();
    mov_w(r12, r4);

    lw_symbol("n", r7);
    next_iter_n := lw_iter(r7, true, r13, iter_n);

    mov_w(r10, r14);

    B := mula16();

    mov_w(r13, r10);

    mov_w(r7, r15);
    add_w_imm(382, r15);
    n_end := r15;
    sw_stack(r15);

    mont_loop_inv_pre_lemma(a, r4, rsa.M0D, A, B,
        iter_b.buff, iter_n.buff, iter_c.buff);
}

procedure mma_loop(
    ghost A: uint32_view_t,
    ghost B: uint32_view_t,
    ghost original_c: seq(uint16),
    ghost iter_c: iter_t,
    ghost a: uint16,
    ghost iter_b: iter_t,
    ghost iter_n: iter_t,
    ghost rsa: rsa_params,
    ghost j: nat)

returns (
    ghost next_A: uint32_view_t,
    ghost next_B: uint32_view_t,
    ghost next_iter_b: iter_t,
    ghost next_iter_c: iter_t,
    ghost next_iter_n: iter_t)

    {:frame false}

    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 4);

        symbols?["n"];
        rsa.M0D == 0x71df;

        iter_c.base_ptr != iter_n.base_ptr;
        iter_c.base_ptr != iter_b.base_ptr;

        1 <= j < NUM_WORDS;
        r5 == a;
        mvar_iter_inv(heap, iter_b, r6, j, (-1));
        mvar_iter_inv(heap, iter_n, r7, j, rsa.M);
        mvar_iter_inv(heap, iter_c, r8, j - 1, (-1));
        r9 == A.uh;
        r10 == B.uh;

        mont_loop_inv(a, r4, A, B,
            iter_b.buff, iter_n.buff, original_c, iter_c.buff, j);

    ensures
        mem == old(mem).(heap := heap);
        mem.heap == old(mem).heap[next_iter_c.base_ptr := B16(next_iter_c.buff)];

        sp == old(sp);
        r5 == a;
        mvar_iter_inv(heap, next_iter_b, r6, j + 1, (-1));
        mvar_iter_inv(heap, next_iter_n, r7, j + 1, rsa.M);
        mvar_iter_inv(heap, next_iter_c, r8, j, (-1));
        r9 == next_A.uh;
        r10 == next_B.uh;

        next_iter_b == b16_iter_load_next(iter_b, true);
        next_iter_c == b16_iter_store_next(iter_c, r14, true);
        next_iter_n == b16_iter_load_next(iter_n, true);

        mont_loop_inv(a, r4, next_A, next_B,
            next_iter_b.buff, next_iter_n.buff, original_c, next_iter_c.buff, j+1);
{
    mov_w(r5, r12);
    next_iter_b := lw_iter(r6, true, r13, iter_b);
    mov_w(r8, r15);
    add_w_imm(2, r15);
    next_iter_c := lw_iter(r15, true, r14, iter_c.(index := j));
    mov_w(r9, r15);

    next_A := mulaa16();
    mov_w(r12, r14);
    mov_w(r13, r9);
    // assert next_A.full == a * iter_b.buff[j] + iter_c.buff[j] + A.uh;

    mov_w(r4, r12);
    next_iter_n := lw_iter(r7, true, r13, iter_n);
    mov_w(r10, r15);

    next_B := mulaa16();
    // assert next_B.full == r4 * iter_n.buff[j] + next_A.lh + B.uh;

    mov_w(r12, r14);
    mov_w(r13, r10);

    next_iter_c := sw_iter(r14, r8, iter_c);
    add_w_imm(2, r8);

    mont_loop_inv_peri_lemma(a, r4, A, B, next_A, next_B, 
        iter_b.buff, iter_n.buff, original_c, iter_c.buff, next_iter_c.buff, j);
}

procedure mma_post(
    ghost A: uint32_view_t,
    ghost B: uint32_view_t,
    ghost original_c: seq(uint16),
    ghost iter_c: iter_t,
    ghost a: uint16,
    ghost iter_b: iter_t,
    ghost iter_n: iter_t,
    ghost j: nat,
    ghost iter_a: iter_t,
    ghost rsa: rsa_params,
    ghost i: nat)

returns (ghost next_iter_c: iter_t)

    {:frame false}

    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 8);

        symbols?["n"];
        rsa.M0D == 0x71df;

        iter_c.base_ptr != iter_n.base_ptr;
        iter_c.base_ptr != iter_b.base_ptr;
        iter_c.base_ptr != iter_a.base_ptr;

        j == NUM_WORDS;
        i < NUM_WORDS;
        r5 == a;
        mvar_iter_inv(heap, iter_b, r6, j, (-1));
        mvar_iter_inv(heap, iter_n, load_symbol(mem, "n"), 0, rsa.M);
        mvar_iter_inv(heap, iter_c, r8, j - 1, (-1));
        r9 == A.uh;
        r10 == B.uh;

        montmul_inv(original_c, iter_a.buff, i, iter_b.buff, rsa);
        iter_a.buff[i] == a;

        mont_loop_inv(a, r4, A, B, iter_b.buff, iter_n.buff,
            original_c, iter_c.buff, j);

    ensures
        sp == old(sp);
    ensures
        next_iter_c.base_ptr == iter_c.base_ptr;
        mvar_iter_inv(heap, next_iter_c, iter_c.base_ptr, 0, (-1));

    ensures
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_c.base_ptr := heap[iter_c.base_ptr]];

        montmul_inv(next_iter_c.buff, iter_a.buff, i+1, iter_b.buff, rsa);
{
    let d0 := r4;
    mov_w_imm(0, r15);
    add_w(r10, r9);
    addc_w(r15, r15);
    next_iter_c := sw_iter(r9, r8, iter_c);
    add_w_imm(2, r8);
    // assert r15 == 0 || r15 == 1;
    let bout: uint1 := if r15 == 0 then 0 else 1;
    // assert r9 < r10 ==> r15 == 1;
    // assert r9 >= r10 ==> r15 == 0;
    let pre_sub_c := next_iter_c.buff;
    mont_loop_inv_post_lemma(a, d0, A, B, 
        iter_b.buff, iter_n.buff, original_c, next_iter_c.buff, bout);

    ghost var next_bout: uint1 := 0;
    if (r9 < r10) {
        add_w_imm((-384), r8);
        mov_w(r8, r12);
        next_iter_c, next_bout := sub_mod(next_iter_c.(index := 0), iter_n.(index := 0));
    }

    mont_loop_cond_sub_lemma(
        a, d0, iter_b.buff, to_nat(iter_n.buff), 
        to_nat(original_c), pre_sub_c, next_iter_c.buff, bout, next_bout);

    montmul_inv_lemma(original_c, next_iter_c.buff, iter_a.buff, i, d0, iter_b.buff, rsa);
    next_iter_c := next_iter_c.(index := 0);
}

procedure mont_mul_add_inner(
    ghost iter_c: iter_t,
    ghost a: uint16,
    ghost iter_b: iter_t,
    ghost iter_n: iter_t,
    ghost iter_a: iter_t,
    ghost rsa: rsa_params,
    ghost i: nat)
returns (ghost next_iter_c: iter_t)

    {:frame false}
    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 10);

        symbols?["n"];
        rsa.M0D == 0x71df;

        iter_c.base_ptr != iter_n.base_ptr;
        iter_c.base_ptr != iter_b.base_ptr;
        iter_c.base_ptr != iter_a.base_ptr;

        mvar_iter_inv(heap, iter_c, r12, 0, (-1));
        r13 == a;
        mvar_iter_inv(heap, iter_b, r14, 0, (-1));
        mvar_iter_inv(heap, iter_n, load_symbol(mem, "n"), 0, rsa.M);

        montmul_inv(iter_c.buff, iter_a.buff, i, iter_b.buff, rsa);
        i < NUM_WORDS;
        iter_a.buff[i] == a;

    ensures
        sp == old(sp);

    ensures
        next_iter_c.base_ptr == iter_c.base_ptr;
        mvar_iter_inv(heap, next_iter_c, iter_c.base_ptr, 0, (-1));

    ensures
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_c.base_ptr := heap[iter_c.base_ptr]];

        montmul_inv(next_iter_c.buff, iter_a.buff, i+1, iter_b.buff, rsa);
{
    let pre_mem := mem;

    ghost var A: uint32_view_t;
    ghost var B: uint32_view_t;
    ghost var next_iter_b: iter_t;
    ghost var next_iter_n: iter_t;
    next_iter_c := iter_c;
    ghost var n_end: uint16;

    A, B, next_iter_b, next_iter_n, n_end := 
        mma_pre(iter_c, a, iter_b, iter_n, rsa);

    let original_c := iter_c.buff;
    let loop_sp := sp;
    let loop_mem := mem;

    ghost var j: nat := 1;

    while (r7 < r15)
        invariant
            sp == loop_sp;
            mem == loop_mem.(heap := heap);
            heap == old(heap)[next_iter_c.base_ptr := B16(next_iter_c.buff)];
            read_top_frame(mem) == seq(n_end);

            symbols?["n"];

            next_iter_b.base_ptr == iter_b.base_ptr;
            next_iter_n.base_ptr == iter_n.base_ptr;
            next_iter_c.base_ptr == iter_c.base_ptr;

            next_iter_c.base_ptr != next_iter_n.base_ptr;
            next_iter_c.base_ptr != next_iter_b.base_ptr;

            1 <= j <= NUM_WORDS;
            r5 == a;
            mvar_iter_inv(heap, next_iter_b, r6, j, (-1));
            mvar_iter_inv(heap, next_iter_n, r7, j, rsa.M);
            mvar_iter_inv(heap, iter_n, load_symbol(mem, "n"), 0, rsa.M);
            mvar_iter_inv(heap, next_iter_c, r8, j - 1, (-1));
            r9 == A.uh;
            r10 == B.uh;
            r15 == n_end;

            mont_loop_inv(a, r4, A, B, next_iter_b.buff, next_iter_n.buff,
                original_c, next_iter_c.buff, j);

            montmul_inv(original_c, iter_a.buff, i, next_iter_b.buff, rsa);

        decreases
            r15 - r7;
    {
        A, B, next_iter_b, next_iter_c, next_iter_n := 
            mma_loop(A, B, original_c, next_iter_c, a, next_iter_b, next_iter_n, rsa, j);
        lw_stack(r15);
        // assert r15 == n_end;
        j := j + 1;
    }

    next_iter_c := mma_post(A, B, original_c,
        next_iter_c, a, next_iter_b, iter_n, j, iter_a, rsa, i);

    assert montmul_inv(next_iter_c.buff, iter_a.buff, i+1, iter_b.buff, rsa);

    assert frames == loop_mem.frames;
    pop_frame(2);
    assert frames == pre_mem.frames;
}

procedure mont_mul_add(
    ghost iter_c: iter_t,
    ghost a: uint16,
    ghost iter_b: iter_t,
    ghost iter_n: iter_t,
    ghost iter_a: iter_t,
    ghost rsa: rsa_params,
    ghost i: nat)

returns (ghost next_iter_c: iter_t)
    {:frame false}
    {:noInline}

    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 24);

        symbols?["n"];
        rsa.M0D == 0x71df;

        iter_c.base_ptr != iter_n.base_ptr;
        iter_c.base_ptr != iter_b.base_ptr;
        iter_c.base_ptr != iter_a.base_ptr;

        mvar_iter_inv(heap, iter_c, r12, 0, (-1));
        r13 == a;
        mvar_iter_inv(heap, iter_b, r14, 0, (-1));
        mvar_iter_inv(heap, iter_n, load_symbol(mem, "n"), 0, rsa.M);

        montmul_inv(iter_c.buff, iter_a.buff, i, iter_b.buff, rsa);
        i < NUM_WORDS;
        iter_a.buff[i] == a;

    ensures
        sp == old(sp);
        r4 == old(r4);
        r5 == old(r5);
        r6 == old(r6);
        r7 == old(r7);
        r8 == old(r8);
        r9 == old(r9);
        r10 == old(r10);

    ensures
        next_iter_c.base_ptr == iter_c.base_ptr;
        mvar_iter_inv(heap, next_iter_c, iter_c.base_ptr, 0, (-1));

    ensures
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_c.base_ptr := heap[iter_c.base_ptr]];
        montmul_inv(next_iter_c.buff, iter_a.buff, i+1, iter_b.buff, rsa);
{
    save_r4__r10();
    next_iter_c := mont_mul_add_inner(iter_c, a, iter_b, iter_n, iter_a, rsa, i);
    assert read_top_frame(mem) == seq(old(r4), old(r5), old(r6), old(r7), old(r8), old(r9), old(r10));
    popm_w(7, r10);
    assert frames == old(frames);
}

#verbatim
}
#endverbatim
