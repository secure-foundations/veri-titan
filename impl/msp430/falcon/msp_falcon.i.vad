include "msp_mq_intt.i.vad"
include "msp_mq_fntt.i.vad"
include "msp_mq_norm.i.vad"
include "msp_circle_product.i.vad"

#verbatim

include "msp_mq_intt.i.dfy"
include "msp_mq_fntt.i.dfy"
include "msp_mq_norm.i.dfy"
include "msp_circle_product.i.dfy"

module msp_falcon {

import opened integers

import opened msp_machine
import opened msp_decls
import opened msp_vale
import opened mem
import opened stack

import opened bv16_op_s
import opened mq_arith_lemmas

import opened pow2_s
import opened falcon_512_i

import opened msp_reg_save
import opened msp_mq_fntt
import opened msp_mq_intt
import opened msp_mq_norm
import opened msp_circle_product

#endverbatim

function rev_omega_inv_powers_mont_table(): seq(uint16) extern;
function rev_mixed_powers_mont_table(): seq(uint16) extern;
function inverse_ntt_scaling_table(): seq(uint16) extern;
function as_elems(s: seq(uint16)): seq(uint16) extern;
function nelems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function bit_rev_ftable_wf(s: seq(uint16)): bool extern;

procedure msp_falcon(
    ghost iter_c0: iter_t,
    ghost iter_s2: iter_t,
    ghost iter_h: iter_t,
    ghost iter_tt: iter_t,
    ghost iter_t1: iter_t,
    ghost iter_t2: iter_t,
    ghost iter_p1: iter_t,
    ghost iter_p2: iter_t)

{:frame false}
{:noInline}

    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 50);

    // requires
    //     set_len(init_unfinished(N)) == 480;
    requires
        elems_iter_inv(heap, iter_c0, r12, 0);
        nelems_iter_inv(heap, iter_s2, r13, 0);

        // writable
        elems_iter_inv(heap, iter_h, r14, 0);
        // writable
        elems_iter_inv(heap, iter_tt, r15, 0);

    requires
        symbols?["bit_rev_table_512"];
        iter_inv(iter_t1, heap,
            load_symbol(mem, "bit_rev_table_512"));
        iter_t1.index == 0;
        bit_rev_ftable_wf(iter_t1.buff);

    requires
        symbols?["scaling_factors"];
        elems_iter_inv(heap, iter_t2,
            load_symbol(mem, "scaling_factors"), 0);
        iter_t2.buff == inverse_ntt_scaling_table();

    requires
        symbols?["rev_omega_inv_powers_mont_table"];
        elems_iter_inv(heap, iter_p1,
            load_symbol(mem, "rev_omega_inv_powers_mont_table"), 0);
        iter_p1.buff == rev_omega_inv_powers_mont_table();

    requires
        symbols?["rev_mixed_powers_mont_table"];
        elems_iter_inv(heap, iter_p2,
            load_symbol(mem, "rev_mixed_powers_mont_table"), 0);
        iter_p2.buff == rev_mixed_powers_mont_table();

    requires
        iter_h.base_ptr != iter_c0.base_ptr;
        iter_h.base_ptr != iter_s2.base_ptr;
        iter_h.base_ptr != iter_tt.base_ptr;
        iter_h.base_ptr != iter_t1.base_ptr;
        iter_h.base_ptr != iter_t2.base_ptr;
        iter_h.base_ptr != iter_p1.base_ptr;
        iter_h.base_ptr != iter_p2.base_ptr;

        iter_tt.base_ptr != iter_c0.base_ptr;
        iter_tt.base_ptr != iter_s2.base_ptr;
        iter_tt.base_ptr != iter_t1.base_ptr;
        iter_tt.base_ptr != iter_t2.base_ptr;
        iter_tt.base_ptr != iter_p1.base_ptr;
        iter_tt.base_ptr != iter_p2.base_ptr;

{
    save_r4__r10();

    ghost var iter_tt' := iter_tt;
    ghost var iter_h' := iter_h;

    mov_w(r15, r4);

    iter_tt' := denormolize(iter_s2, iter_tt');

    mov_w(r14, r12);
    iter_h' := fntt(iter_h', iter_p2);
    mov_w(r12, r5);

    mov_w(r4, r12);
    iter_tt' := fntt(iter_tt', iter_p2);

    mov_w(r5, r13);
    iter_tt' := circle_product(iter_tt', iter_h');

}




#verbatim
}
#endverbatim