include "../../../spec/arch/msp430/decls.i.vad"

#verbatim

include "../../../spec/arch/msp430/decls.i.dfy"
include "../../../../glue/msp430/falcon/mq_arith_lemmas.dfy"

module msp_bit_rev {

import opened integers

import opened msp_machine
import opened msp_decls
import opened msp_vale
import opened mem
import opened stack

import opened bv16_op_s
import opened mq_arith_lemmas
import opened DivMod

import opened ntt_index
import opened pow2_s
import opened falcon_512_i

#endverbatim

type rev_view: Type(0) extern;
function operator(.ti) (m: rev_view): nat extern;
function operator(.b) (m: rev_view): seq(uint16) extern;

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function b16_iter_inv(iter: b16_iter, heap: heap_t, address: int): bool extern;

type pow2_t: Type(0) extern;
function init_unfinished(len: pow2_t): set(nat) extern;
function build_view(a: seq(uint16), i: nat, len: pow2_t): rev_view extern;
function is_bit_rev_shuffle(a: seq(uint16), b: seq(uint16), len: pow2_t): bool extern;
function bit_rev_view_init(a: seq(uint16)): rev_view extern;
function bit_rev_view_inv_peri_lemma(a: seq(uint16), next_b: seq(uint16), view: rev_view, table: seq(uint16)): rev_view extern;
function bit_rev_index_lemma(a: seq(uint16), ftable: seq(uint16), li: nat, ri: nat, ti: nat): void extern;
function bit_rev_view_inv_post_lemma(a: seq(uint16), view: rev_view): void  extern;
function bit_rev_ftable_wf(table: seq(uint16)): bool extern;
function bit_rev_shuffle_inv(a: seq(uint16), view: rev_view): bool extern;
const N: pow2_t extern;

procedure bit_rev(
    ghost iter_a: iter_t,
    ghost iter_p: iter_t)
returns (ghost iter_a': iter_t)
    {:frame false}
    {:noInline}

    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 12);

    requires
        elems_iter_inv(heap, iter_a, r12, 0);

        symbols?["bit_rev_table_512"];
        iter_inv(iter_p, heap,
            load_symbol(mem, "bit_rev_table_512"));
        iter_p.index == 0;

        bit_rev_ftable_wf(iter_p.buff);

        iter_a.base_ptr != iter_p.base_ptr;

    ensures
        sp == old(sp);
        r4 == old(r4);
        r5 == old(r5);
        r6 == old(r6);
        r7 == old(r7);
        r8 == old(r8);
        r9 == old(r9); 
        r10 == old(r10); 
        r11 == old(r11);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

    ensures
        elems_iter_inv(heap, iter_a', r12, 0);
        iter_a'.base_ptr == iter_a.base_ptr;

    ensures
        mem == old(mem).(heap := heap);
        heap == old(heap)
            [iter_a.base_ptr := heap[iter_a.base_ptr]];

    ensures
        is_bit_rev_shuffle(iter_a.buff, iter_a'.buff, N);
{
    pushm_w(6, r10);
    let mem0 := mem;
    let init_a := iter_a.buff;
    
    ghost var view := bit_rev_view_init(init_a);
    ghost var iter_p' := iter_p;
    iter_a' := iter_a;

    lw_symbol("bit_rev_table_512", r9);
    assume seq_len(iter_p.buff) == 480;

    mov_w(r9, r10);
    add_w_imm(960, r10);

    ghost var ti :nat := 0;

    while (r9 < r10)
        invariant
            r4 == old(r4);
            r10 == iter_p.base_ptr + 960;
            r11 == old(r11);
            r13 == old(r13);
            r14 == old(r14);
            r15 == old(r15);

        invariant
            elems_iter_inv(heap, iter_a', r12, 0);
            iter_a'.base_ptr == iter_a.base_ptr;

            iter_inv(iter_p', heap, r9);
            iter_p'.base_ptr == iter_p.base_ptr;
            iter_p'.index == 2 * ti;
            seq_len(iter_p'.buff) == 480;    
        
        invariant
            mem == mem0.(heap := heap);
            heap == mem0.heap
                [iter_a'.base_ptr := heap[iter_a'.base_ptr]];

        invariant
            view == build_view(init_a, ti, N);
            bit_rev_shuffle_inv(init_a, view);
            view.ti == ti;
            view.b == iter_a'.buff;

        decreases
            480 - ti * 2;
    {
        iter_p' := lw_iter(r9, true, r8, iter_p');
        iter_p' := lw_iter(r9, true, r7, iter_p');

        let li := r8;
        let ri := r7;

        add_w(r8, r8);
        add_w(r7, r7);

        add_w(r12, r8);
        add_w(r12, r7);

        bit_rev_index_lemma(init_a, iter_p.buff, li, ri, ti);

        iter_a' := lw_iter(r8, false, r6, iter_a'.(index := li));
        iter_a' := lw_iter(r7, false, r5, iter_a'.(index := ri));
        
        iter_a' := sw_iter(r5, r8, iter_a'.(index := li));
        iter_a' := sw_iter(r6, r7, iter_a'.(index := ri));

        view := bit_rev_view_inv_peri_lemma(init_a, iter_a'.buff, view, iter_p'.buff);
        iter_a' := iter_a'.(index := 0);
        ti := ti + 1;
    }

    bit_rev_view_inv_post_lemma(init_a, view);

    popm_w(6, r10);
}

#verbatim
}
#endverbatim