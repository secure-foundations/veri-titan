include "msp_mq_arith.i.vad"

#verbatim
include "msp_mq_arith.i.dfy"

module msp_mq_norm {

import opened integers

import opened msp_machine
import opened msp_decls
import opened msp_vale
import opened mem
import opened stack

import opened bv16_op_s
import opened mq_arith_lemmas

import opened pow2_s
import opened falcon_512_i

import opened msp_mq_arith
// import opened mq_polysub

#endverbatim

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function nelems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function denorm_inv(nv: seq(uint16), dnv: seq(uint16), i: nat): bool extern;
function denorm_inv_peri_lemma(nv: seq(uint16), dnv: seq(uint16), i: nat, a: uint16, b: uint16): void extern;

procedure denormolize(
    ghost iter_s2: iter_t,
    ghost iter_tt: iter_t)
returns (ghost iter_tt': iter_t)
 
    requires
        nelems_iter_inv(heap, iter_s2, r13, 0);
        elems_iter_inv(heap, iter_tt, r15, 0);
        iter_s2.base_ptr != iter_tt.base_ptr;

    modifies
        mem; heap; flags;
        r5; r8; r10; r13; r15;
    
    ensures
        iter_tt'.base_ptr == iter_tt.base_ptr;
        elems_iter_inv(heap, iter_tt', r15, 0);

    ensures
        mem == old(mem).(heap := heap);
        heap == old(heap)
            [iter_tt.base_ptr := heap[iter_tt.base_ptr]];

    ensures
        denorm_inv(iter_s2.buff, iter_tt'.buff, 512);
{
    ghost var iter_s2' := iter_s2;
    iter_tt' := iter_tt;

    mov_w(r15, r10);
    add_w_imm(1024, r10);

    ghost var i:nat := 0;
    
    while (r15 < r10)
        invariant
            r10 == iter_tt.base_ptr + 1024;
            iter_s2'.base_ptr == iter_s2.base_ptr;
            nelems_iter_inv(heap, iter_s2', r13, i);

            iter_tt'.base_ptr == iter_tt.base_ptr;
            elems_iter_inv(heap, iter_tt', r15, i);

            mem == old(mem).(heap := heap);
            heap == old(heap)
                [iter_tt.base_ptr := heap[iter_tt.base_ptr]];

        invariant
            denorm_inv(iter_s2.buff, iter_tt'.buff, i);

        decreases
            r10 - r15;
    {
        iter_s2' := lw_iter(r13, true, r5, iter_s2');
        mov_w(r5, r8);
        let a := r8;

        rla_w(r5);
        cond_set_Q(r5);

        add_w(r5, r8);

        denorm_inv_peri_lemma(iter_s2'.buff, iter_tt'.buff, i, a, r8);

        iter_tt' := sw_iter(r15, true, r8, iter_tt');

        i := i + 1;
    }

    iter_tt' := iter_tt'.(index := 0);
    add_w_imm((-1024), r15);
}

#verbatim
}
#endverbatim