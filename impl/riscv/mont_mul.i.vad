include "../../arch/riscv/decls.i.vad"
include "mont_mul_add.i.vad"

#verbatim
include "../../impl/riscv/mont_mul_add.i.dfy"
include "../../../lib/bv32_mm_lemmas.i.dfy"

module mont_mul {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened mem
import opened stack

import opened mul32
import opened sub_mod
import opened mont_mul_add
import opened bv32_mm_lemmas

#endverbatim

function seq_zero #[a: Type(0)](len: int): seq(a) extern;

type mm_vars: Type(0) extern;
function operator(.mm_frame_ptr) (vars: mm_vars): nat extern;
function operator(.mma_frame_ptr) (vars: mm_vars): nat extern;
function operator(.d0) (vars: mm_vars): uint32 extern;
function operator(.iter_a) (vars: mm_vars): iter_t extern;
function operator(.iter_a := ) (vars: mm_vars, it: iter_t): mm_vars extern;
function operator(.iter_b) (vars: mm_vars): iter_t extern;
function operator(.iter_b := ) (vars: mm_vars, it: iter_t): mm_vars extern;
function operator(.iter_c) (vars: mm_vars): iter_t extern;
function operator(.iter_c := ) (vars: mm_vars, it: iter_t): mm_vars extern;
function operator(.iter_n) (vars: mm_vars): iter_t extern;
function operator(.iter_n := ) (vars: mm_vars, it: iter_t): mm_vars extern;

function to_mma_vars(vars: mm_vars, a_i: uint32): mma_vars extern;

function mm_vars_inv(
    vars: mm_vars,
    heap: heap_t,
    a_ptr: int, a_idx: int,
    n_ptr: int, n_idx: int,
    c_ptr: int, c_idx: int,
    b_ptr: int, b_idx: int,
    rsa: rsa_params): bool extern;

function montmul_inv_lemma_0(
    a: seq(uint32),
    x: seq(uint32), 
    y: seq(uint32), 
    rsa: rsa_params): void extern;

 function montmul_inv_lemma_1(
    a_view: seq(uint32),
    x: seq(uint32),
    y: seq(uint32),
    rsa: rsa_params): void extern;

function IsModEquivalent(
    a: nat,
    b: nat,
    n: nat): bool extern;

procedure mm_clear(ghost iter_c: iter_t)
    returns (ghost next_iter_c: iter_t)

    requires iter_safe(iter_c, heap, s1);
    requires seq_len(iter_c.buff) == 96;
    requires iter_c.index == 0;
    requires s4 == iter_c.base_ptr + 384;
    requires s1 == iter_c.base_ptr;

    reads
        x0; s4;
    modifies 
        s1; heap;

    ensures
        heap == old(heap)[next_iter_c.base_ptr := B32(next_iter_c.buff)];
        next_iter_c.base_ptr == iter_c.base_ptr;
        iter_inv(next_iter_c, heap, old(s1));
        seq_len(next_iter_c.buff) == 96;
        next_iter_c.buff == seq_zero(96);
        next_iter_c.index == 0;
{
    let ptr_c := iter_c.base_ptr;
    ghost var iter_c := iter_c;

    assume iter_c.buff[..0] == seq_zero(0);

    while (s1 < s4) 
        invariant
            s4 == ptr_c + 384;
            s1 == ptr_c + 4 * iter_c.index;

            iter_c.base_ptr == ptr_c;
            iter_inv(iter_c, heap, s1);
            seq_len(iter_c.buff) == 96;
            
            heap == old(heap)[ptr_c := B32(iter_c.buff)];

            iter_c.buff[..iter_c.index] == seq_zero(iter_c.index);
        decreases
            s4 - s1;
    {
        iter_c := sw_next(x0, s1, 0, iter_c);
        addi(s1, s1, 4);
    }
    next_iter_c := iter_c.(index := 0);
}

procedure mm_save_regs()
    requires
        sp == STACK_START() - 40;

    modifies
        sp; mem; flat;
    reads
        ra; s0; s1; s2; s3; s4; s5;

    ensures
        sp == STACK_START() - 68;
        mem == stack_push_batch(old(mem), old(flat), seq(s5, s4, s3, s2, s1, s0, ra));
        stack_depth(mem) == stack_depth(old(mem)) + 1;
{
    push_frame((-28));
    sw_stack(ra, 24);
    sw_stack(s0, 20);
    sw_stack(s1, 16);
    sw_stack(s2, 12);
    sw_stack(s3,  8);
    sw_stack(s4,  4);
    sw_stack(s5,  0);

    let target := stack_push_batch(old(mem), old(flat),
        seq(s5, s4, s3, s2, s1, s0, ra));
    assert top_frame(target.frames) == top_frame(mem.frames);
}

procedure mm_pre_loop(
    ghost vars: mm_vars,
    ghost rsa: rsa_params)
    returns (ghost mut_vars: mm_vars)

    requires a0 == rsa.M0D;

    requires mm_vars_inv(vars, heap,
        a2, 0 /* a */, a4, 0, /* n */ a1, 0, /* c */ a3, 0, /* b */ rsa);

    reads x0;

    modifies
        s0; s1; s2; s3; s4; s5;
        a0; a1; a2; a3; a4; a5; a6;
        ra; heap; flat;
    
    ensures
        s0 == rsa.M0D;
        s1 == vars.iter_c.base_ptr;
        s2 == mut_vars.iter_a.base_ptr;
        s3 == vars.iter_b.base_ptr;

        mut_vars.iter_a.index == 0;
        s4 == mut_vars.iter_a.base_ptr + 384;
        s2 <= s4;

        s5 == old(a4);
  
        mm_vars_inv(mut_vars, heap,
        s2, 0 /* a */, s5, 0, /* n */ s1, 0, /* c */ s3, 0, /* b */ rsa);

        montmul_inv(mut_vars.iter_c.buff, mut_vars.iter_a.buff, mut_vars.iter_a.index, mut_vars.iter_b.buff, rsa);

        heap == old(heap)[mut_vars.iter_c.base_ptr := B32(mut_vars.iter_c.buff)];

        mut_vars == vars.(iter_a := mut_vars.iter_a)
                        .(iter_c := mut_vars.iter_c);

        mut_vars.iter_a.base_ptr == vars.iter_a.base_ptr;
        mut_vars.iter_c.base_ptr == vars.iter_c.base_ptr;
{
    mv(s0, a0); // s0 = rsa.M0D
    mv(s1, a1); // s1 c *
    mv(s2, a2); // s2 a *
    mv(s3, a3); // s3 b *
    mv(s5, a4); // s5 n *

    addi(s4, s1, 384);

    let next_iter_c := mm_clear(vars.iter_c);
    mut_vars := vars.(iter_c := next_iter_c);

    mv(s1, a1);
    addi(s4, s2, 384);

    montmul_inv_lemma_0(mut_vars.iter_c.buff, mut_vars.iter_a.buff, mut_vars.iter_b.buff, rsa);
}

procedure mont_mul(
    ghost vars: mm_vars,
    ghost rsa: rsa_params)
    returns (ghost next_iter_c : iter_t)

    {:noInline}

    {:timeLimitMultiplier 3} 

    requires sp == STACK_START() - 40;

    requires a0 == rsa.M0D;

    requires mm_vars_inv(vars, heap,
        a2, 0 /* a */, a4, 0, /* n */ a1, 0, /* c */ a3, 0, /* b */ rsa);

    reads x0;

    modifies
        sp; s0; s1; s2; s3; s4; s5;
        a0; a1; a2; a3; a4; a5; a6; ra;
        heap; mem; flat;
    
//     ensures
//         ra == old(ra);
//         s0 == old(s0);
//         s1 == old(s1);
//         s2 == old(s2);
//         s3 == old(s3);
//         s4 == old(s4);
//         s5 == old(s5);
//         s6 == old(s6);
//         s7 == old(s7);
//         s8 == old(s8);
//         sp == old(sp); 

//         valid_frame_ptr(heap, vars.mma_frame_ptr, 12);
//         valid_frame_ptr(heap, vars.mm_frame_ptr, 8);
//         mvar_iter_inv(heap, next_iter_c, (vars.iter_c.base_ptr), 0, NA);

//         heap == old(heap)[vars.mma_frame_ptr := heap[vars.mma_frame_ptr]]
//                 [vars.mm_frame_ptr := heap[vars.mm_frame_ptr]]
//                 [next_iter_c.base_ptr := next_iter_c.buff];

//         montmul_inv(next_iter_c.buff, vars.iter_a.buff, NUM_WORDS, vars.iter_b.buff, rsa);
{
    mm_save_regs();

    ghost var i: nat := 0;
    ghost var mem0 := mem;

    ghost var mut_vars := vars;
    mut_vars := mm_pre_loop(mut_vars, rsa);

    while (s2 < s4) 
        invariant
            s0 == rsa.M0D;
            s1 == vars.iter_c.base_ptr;
            s2 == mut_vars.iter_a.base_ptr + 4 * i;
            s3 == vars.iter_b.base_ptr;

            i == mut_vars.iter_a.index;
            s4 == mut_vars.iter_a.base_ptr + 384;
            s2 <= s4;

            sp == STACK_START() - 68;

            s5 == old(a4);
            s6 == old(s6);
            s7 == old(s7);
            s8 == old(s8);

            mm_vars_inv(mut_vars, heap,
            s2, i /* a */, s5, 0, /* n */ s1, 0, /* c */ s3, 0, /* b */ rsa);

            montmul_inv(mut_vars.iter_c.buff, mut_vars.iter_a.buff, mut_vars.iter_a.index, mut_vars.iter_b.buff, rsa);

            mem.heap == mem0.heap[mut_vars.iter_c.base_ptr := B32(mut_vars.iter_c.buff)];

            mut_vars == vars.(iter_a := mut_vars.iter_a)
                            .(iter_c := mut_vars.iter_c);

            10 == seq_len(read_top_frame(mem));

            mut_vars.iter_a.base_ptr == vars.iter_a.base_ptr;
            mut_vars.iter_c.base_ptr == vars.iter_c.base_ptr;
        decreases
            s4 - s2;
    {
        mv(a1, s1); // c
        mv(a0, s0); // M0D
        mv(a3, s3); // b
        mv(a4, s5); // n

        let next_iter_a := lw_next(a2, s2, 0, mut_vars.iter_a);

        next_iter_c := mont_mul_add(to_mma_vars(mut_vars, a2), rsa);

        addi(s2, s2, 4);
        i := i + 1;

        mut_vars := mut_vars.(iter_c := next_iter_c).(iter_a := next_iter_a);
    }

    next_iter_c := mut_vars.iter_c;
    montmul_inv_lemma_1(mut_vars.iter_c.buff, mut_vars.iter_a.buff, mut_vars.iter_b.buff, rsa);


    // push_frame((-28));
    // sw_stack(ra, 24);
    // sw_stack(s0, 20);
    // sw_stack(s1, 16);
    // sw_stack(s2, 12);
    // sw_stack(s3,  8);
    // sw_stack(s4,  4);
    // sw_stack(s5,  0);

    // lw_stack(ra, 28, 7);
    // lw_stack(s0, 24, 6);
    // lw_stack(s1, 20, 5);
    // lw_stack(s2, 16, 4);
    // lw_stack(s3, 12, 3);
    // lw_stack(s4,  8, 2);
    // lw_stack(s5,  4, 1);
    // addi(sp, sp, 32);
}


#verbatim
}
#endverbatim
