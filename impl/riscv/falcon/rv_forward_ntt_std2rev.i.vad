include "../../../arch/riscv/decls.i.vad"
include "mq_arith.i.vad"
include "rv_reg_save.i.vad"

#verbatim

include "mq_arith.i.dfy"
include "rv_reg_save.i.dfy"

module rv_forward_ntt_std2rev {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale
import opened mem
import opened stack

import opened bv32_ops
import opened bv32_falcon_lemmas

import opened pows_of_2
import opened ntt_index
import opened mq_polys
import opened poly_view
import opened nth_root
import opened forward_ntt

import opened rv_reg_save
import opened mq_arith

#endverbatim

function buff_as_nsized(s: seq(uint16)): seq(uint16) extern;

function rev_mixed_powers_mont_table(): seq(uint16) extern;
function rev_mixed_powers_mont_table_lemma(t: pow2_t, d: pow2_t, j: nat): void extern;
function rev_mixed_powers_mont_x_value(i: nat, d: pow2_t): (r: uint16) extern;

type loop_view: Type(0) extern;
function operator(.hsize) (p :loop_view): pow2_t extern;
function build_loop_view(a: seq(uint16), d: pow2_t): loop_view extern;
function forward_lsize(v: loop_view): pow2_t extern;

function fvar_iter_inv(heap: heap_t, iter: b16_iter, address: int, index: int): bool extern;

function block_size(c: pow2_t): pow2_t extern;

function pow2_t_cons(n: nat, exp: nat): pow2_t extern;
function forward_j_loop_inv(a: seq(uint16), hcount: pow2_t, j: nat, u: nat, view: loop_view): bool extern;
function forward_j_loop_inv_pre_lemma(a: seq(uint16), hcount: pow2_t, view: loop_view): void extern;
function forward_j_loop_inv_post_lemma(a: seq(uint16), hcount: pow2_t, j: nat, u: nat, view: loop_view): void extern;

function forward_s_loop_inv(a: seq(uint16), d: pow2_t, j: nat, bi: nat, view: loop_view): bool extern;
function forward_s_loop_inv_pre_lemma(a: seq(uint16), d: pow2_t, j: nat, t: pow2_t, u: nat, ot3:nat, t3: nat, t6: nat, s5: nat, view: loop_view): void extern;
function forward_s_loop_inv_post_lemma(a: seq(uint16), d: pow2_t, j: nat, u: nat, bi: nat, ot3: nat, t3: nat, t6: nat, view: loop_view): void extern;
function forward_s_loop_index_lemma(a: seq(uint16), d: pow2_t, j: nat, bi: nat, s4: nat, s2: nat, t4: nat, t5: nat, t6: nat, view: loop_view): (s: nat) extern;
function forward_s_loop_update(a: seq(uint16), a': seq(uint16), d: pow2_t, j: nat, bi: nat, s: nat, e: uint32, o: uint32, view: loop_view): bool extern;
function forward_s_loop_inv_peri_lemma(a: seq(uint16), a': seq(uint16), d: pow2_t, j: nat, bi: nat, s: nat, e: uint32, o: uint32, view: loop_view): void extern;

function forward_ntt_eval_all(a: seq(uint16), coeffs: seq(uint16)): bool extern;
function forward_t_loop_inv(a: seq(uint16), d: pow2_t, c: seq(uint16)): bool extern;
function forward_t_loop_inv_pre_lemma(c: seq(uint16)): void extern;
function forward_t_loop_inv_post_lemma(a: seq(uint16), one: pow2_t, c: seq(uint16)): void extern;

procedure forward_s_loop(ghost iter_a: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost j: nat,
    ghost bi: nat,
    ghost view: loop_view)

    returns (ghost iter_a': b16_iter)

    {:frame false}

    requires
        a0 == 12289;
        a5 == t.full;

        t1 == 0xffffcfff;
        t2 == j;
        t3 == 2 * (j * (2 * d.full)) + 2 * d.full;
        t6 == 2 * d.full;

        s2 == 2 * bi + 2 * (j * (2 * d.full));// s

    requires
        fvar_iter_inv(heap, iter_a, s4, 0);
        forward_s_loop_inv(iter_a.buff, d, j, bi, view);
        bi < d.full;
        s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R);

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s2 == old(s2);
        s3 == old(s3);
        s4 == old(s4);
        s5 == old(s5);

        t1 == old(t1);
        t2 == old(t2); // j 
        t3 == old(t3);
        t6 == old(t6);
        ra == old(ra);

    ensures
        iter_a'.base_ptr == iter_a.base_ptr;
        fvar_iter_inv(heap, iter_a', s4, 0);
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];

    ensures
        forward_s_loop_inv(iter_a'.buff, d, j, bi+1, view);
{
    add(t4, s4, s2);
    add(t5, t4, t6);

    let s := forward_s_loop_index_lemma(iter_a.buff, d, j, bi, s4, s2, t4, t5, t6, view);

    lhu(a1, t5, 0, iter_a.(index := s + d.full)); // a[s + d]

    assert a1 == iter_a.buff[s + d.full];

    ntt_inline_mq_montymul();

    assert a1 == montmul(iter_a.buff[s + d.full], s5);

    lhu(a2, t4, 0, iter_a.(index := s)); // a[s]

    assert a2 == iter_a.buff[s];

    ntt_inline_mq_sub();
    let o := a3;
    iter_a' := sh_next(a3, t5, 0, false, iter_a.(index := s + d.full));
    // assert iter_a'.buff[s + d.full] == o;
    
    ntt_inline_mq_add(); // a2 + a1
    let e := a3;
    iter_a' := sh_next(a3, t4, 0, false, iter_a'.(index := s));

    // assert s_loop_update(iter_a.buff, iter_a'.buff, d, j, bi, s, e, o, view);
    forward_s_loop_inv_peri_lemma(iter_a.buff, iter_a'.buff, d, j, bi, s, e, o, view);

    iter_a' := iter_a'.(index := 0);
}

procedure forward_j_loop(ghost iter_a: b16_iter,
    ghost iter_p: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost j: nat,
    ghost u: nat,
    ghost view: loop_view)

    returns (ghost iter_a': b16_iter)

    {:frame false}

    requires
        a0 == 12289; // Q
        a5 == t.full;
        t1 == 0xffffcfff; // -Q
        t2 == j;
        t3 == 2 * u;
        t6 == 2 * d.full;

    requires
        fvar_iter_inv(heap, iter_p, s3, 0);
        fvar_iter_inv(heap, iter_a, s4, 0);
        iter_a.base_ptr != iter_p.base_ptr;

        iter_p.buff == rev_mixed_powers_mont_table();

    requires
        N == pow2_t_cons(512, 9);
        forward_j_loop_inv(iter_a.buff, d, j, u, view);
        j < forward_lsize(view).full;
        t == forward_lsize(view);

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s3 == old(s3);
        s4 == old(s4);

        t1 == old(t1);
        t2 == old(t2); // j 
        t3 == 2 * (u + 2 * d.full);
        t6 == old(t6);
        ra == old(ra);

        iter_a'.base_ptr == iter_a.base_ptr;
        fvar_iter_inv(heap, iter_a', s4, 0);
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];

    ensures
        forward_j_loop_inv(iter_a'.buff, d, j+1, u + 2 * d.full, view);
{
    iter_a' := iter_a;

    add(s5, a5, t2);
    slli(s5, s5, 1);

    mv(s2, t3); // s2 = 2 * s
    add(t3, t3, t6);

    forward_s_loop_inv_pre_lemma(iter_a'.buff, d, t2, t, u, s2, t3, t6, s5, view);
    add(s5, s5, s3);

    let _ := lhu_next(s5, s5, 0, false, iter_p.(index := t.full + j));
    // assert s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R); // w 

    ghost var bi:nat := 0;
    assert t3 == 2 * u + 2 * d.full;

    while (s2 < t3)
        invariant
            a0 == 12289;
            a5 == t.full;

            s1 == old(s1);
            s2 == 2 * bi + 2 * u; // s
            s3 == old(s3);
            s4 == old(s4);

            t1 == 0xffffcfff;
            t3 == 2 * u + 2 * d.full;
            t2 == old(t2); // j 
            t6 == 2 * d.full;
            ra == old(ra);

        invariant
            fvar_iter_inv(heap, iter_a', s4, 0);
            mem == old(mem).(heap := heap);
            heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
        
        invariant
            forward_s_loop_inv(iter_a'.buff, d, j, bi, view);
            s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R);

        decreases
            t3 - s2;
    {
        iter_a' := forward_s_loop(iter_a', t, d, j, bi, view);
        bi := bi + 1;
        addi(s2, s2, 2);
    }

    let ot3 := t3;
    add(t3, t3, t6);

    forward_s_loop_inv_post_lemma(iter_a'.buff, d, j, u, bi, ot3, t3, t6, view);
}

procedure forward_t_loop(ghost iter_a: b16_iter,
    ghost iter_p: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost coeffs: seq(uint16))
    returns (ghost iter_a': b16_iter)

    {:frame false}

    requires
        fvar_iter_inv(heap, iter_p, s3, 0);
        fvar_iter_inv(heap, iter_a, s4, 0);
        iter_a.base_ptr != iter_p.base_ptr;

    requires
        N == pow2_t_cons(512, 9);
        a0 == 12289; // Q
        a5 == t.full;
        t1 == 0xffffcfff; // -Q
        t6 == 2 * d.full;

    requires
        0 <= d.exp < N.exp;
        forward_t_loop_inv(iter_a.buff, pow2_double(d), coeffs);
        iter_p.buff == rev_mixed_powers_mont_table();
        t == block_size(pow2_double(d));

    reads
        s3; s4;

    modifies
        mem; heap;

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s3 == old(s3);
        s4 == old(s4);

        t1 == old(t1);
        t6 == old(t6);
        ra == old(ra);

        mem == old(mem).(heap := heap);
        fvar_iter_inv(heap, iter_a', s4, 0);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
    
    ensures
        forward_t_loop_inv(iter_a'.buff, d, coeffs);
{
    li(t2, 0);
    li(t3, 0);

    ghost var view := build_loop_view(buff_as_nsized(coeffs), d);

    ghost var j :nat := 0;
    ghost var u :nat := 0;

    iter_a' := iter_a;

    forward_j_loop_inv_pre_lemma(iter_a'.buff, d, view);

    while (t2 < a5)
        invariant
            a0 == 12289;
            a5 == t.full;

            s1 == old(s1);
            s3 == old(s3);
            s4 == old(s4);

            t1 == 0xffffcfff;
            t2 == j;
            t3 == 2 * u;
            t6 == 2 * d.full;
            ra == old(ra);

        invariant
            iter_a.base_ptr != iter_p.base_ptr;
            fvar_iter_inv(heap, iter_p, s3, 0);
            iter_a'.base_ptr == iter_a.base_ptr;
            fvar_iter_inv(heap, iter_a', s4, 0);
            heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
            mem == old(mem).(heap := heap);

        invariant
            forward_j_loop_inv(iter_a'.buff, d, j, u, view);

        decreases
            a5 - t2;
    {
        iter_a' := forward_j_loop(iter_a', iter_p, t, d, j, u, view);
        addi(t2, t2, 1);
        j := j + 1;
        u := u + 2 * d.full;
    }

    forward_j_loop_inv_post_lemma(iter_a'.buff, d, j, u, view);
}

procedure forward_ntt_std2rev(
    ghost iter_a: b16_iter,
    ghost iter_p: b16_iter)

returns (ghost iter_a': b16_iter)

    {:noInline}
    {:frame false}
    
    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 24);

    requires
        fvar_iter_inv(heap, iter_a, a0, 0);
        symbols?["ntt512_mixed_powers_rev"];
        fvar_iter_inv(heap, iter_p,
            load_symbol(mem, "ntt512_mixed_powers_rev"), 0);
        iter_a.base_ptr != iter_p.base_ptr;

    requires
        N == pow2_t_cons(512, 9);
        iter_p.buff == rev_mixed_powers_mont_table();

    ensures
        s0 == old(s0);
        s1 == old(s1);
        s2 == old(s2);
        s3 == old(s3);
        s4 == old(s4);

    ensures
        fvar_iter_inv(heap, iter_a', iter_a'.base_ptr, 0);

    ensures
        mem == old(mem).(heap := heap);
        iter_a'.base_ptr == iter_a.base_ptr;
        heap == old(heap)
            [iter_a'.base_ptr := heap[iter_a'.base_ptr]];
        
    ensures
        forward_ntt_eval_all(iter_a'.buff, iter_a.buff);
{
    save_s0__r5();

    let mem0 := mem;
    iter_a' := iter_a;

    lw_symbol(s3, "ntt512_mixed_powers_rev");

    mv(s4, a0);

    li(t1, 0xffffcfff); // -Q
    li(a0, 12289); // Q

    li(s1, 9);

    li(t6, 1024);
    ghost var d := N;

    li(a5, 1); // t 
    ghost var t := pow2(0);
    assume t.full == 1;

    forward_t_loop_inv_pre_lemma(iter_a.buff);

    while (s1 > x0)
        invariant
            iter_a'.base_ptr != iter_p.base_ptr;
            fvar_iter_inv(heap, iter_a', s4, 0);
            iter_a'.base_ptr == iter_a.base_ptr;
            fvar_iter_inv(heap, iter_p, s3, 0);

            mem == mem0.(heap := heap);
            heap == old(heap)
                [iter_a'.base_ptr := heap[iter_a'.base_ptr]];

        invariant
            t1 == 0xffffcfff;
            a0 == 12289;
            s1 == d.exp;
            t6 == 2 * d.full;
            a5 == t.full;
            ra == old(ra);

            0 <= d.exp <= N.exp;
            s1 == 0 ==> d.exp == 0;

            t == block_size(d);

        invariant
            forward_t_loop_inv(iter_a'.buff, d, iter_a.buff);
            // iter_p.buff == rev_mixed_powers_mont_table();
        decreases s1;
    {
        assert s1 != 0;
        half(t6);
        d := pow2_half(d);

        iter_a' := forward_t_loop(iter_a', iter_p, t, d, iter_a.buff);

        t := p2_double(a5, t);
        addi(s1, s1, (-1));
    }

    restore_s0__r5();
    forward_t_loop_inv_post_lemma(iter_a'.buff, d, iter_a.buff);
}

#verbatim
}
#endverbatim