include "../../../spec/arch/otbn/decls.i.vad"

#verbatim

include "../../../spec/arch/otbn/decls.i.dfy"
include "../../../../glue/otbn/rsa/bv256_mm_lemmas.i.dfy"

module cond_sub_to_reg {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale
import opened mem

import opened integers
import opened bv256_mm_lemmas

#endverbatim

function subb_inv(dst: seq(uint256),
    carry: uint1,
    src1: seq(uint256),
    src2: seq(uint256),
    index: int) : bool extern;

ghost procedure subb_inv_pre_lemma(
    ghost dst: seq(uint256),
    ghost src1: seq(uint256),
    ghost src2: seq(uint256)) extern;

ghost procedure subb_inv_peri_lemma(
    ghost dst: seq(uint256),
    ghost new_carry: uint1,
    ghost src1: seq(uint256),
    ghost src2: seq(uint256),
    ghost old_carry: uint1,
    ghost index: int) extern;

ghost procedure subb_inv_post_lemma(
    ghost dst: seq(uint256),
    ghost carry: uint1,
    ghost src1: seq(uint256),
    ghost src2: seq(uint256)) extern;

procedure cond_sub_to_reg_inner(
    ghost init_view: seq(uint256),
    ghost prev_view: seq(uint256),
    ghost iter: iter_t)

    returns (
        ghost next_view: seq(uint256),
        ghost next_iter: iter_t)

    requires
        x8 == 4 + iter.index;
        x12 == 30;
        x13 == 24;

        iter_safe(iter, heap, x16);
        seq_len(iter.buff) == NUM_WORDS;

        valid_wdr_view(wdrs, prev_view, 4, NUM_WORDS);

        seq_len(init_view) == NUM_WORDS;
        init_view[iter.index..] == wdrs[x8..4 + NUM_WORDS];

        subb_inv(prev_view, bool_to_uint1(fgroups.fg0.cf),
            init_view, iter.buff, iter.index);

    reads
        w3; w31; flat; heap;

    modifies
        x8; x12; x13; x16;
        w24; w30;
        wdrs; fgroups;

    ensures
        x8 == 4 + next_iter.index;
        x12 == 30;
        x13 == 24;

        iter_inv(next_iter, heap, x16);
        next_iter == b256_iter_load_next(iter, true);

        w3 == old(w3);
        w31 == old(w31);

        valid_wdr_view(wdrs, next_view, 4, NUM_WORDS);

        init_view[next_iter.index..] == wdrs[x8..4 + NUM_WORDS];

        subb_inv(next_view, bool_to_uint1(fgroups.fg0.cf),
            init_view, next_iter.buff, next_iter.index);
{
    /* load limb of subtrahend (input B) to w24 */
    next_iter := bn_lid_safe(x13, false, 0, x16, true, iter);
    assert w24 == iter.buff[iter.index];

    /* load limb of minuend (input C) to w30 */
    bn_movr(x12, false, x8, false);
    assert w30 == init_view[iter.index];

    /* perform subtraction for a limb */
    let old_carry := bool_to_uint1(fgroups.fg0.cf);
    bn_subb(w24, w30, w24, SFT_DFT, 0);
    let new_carry := bool_to_uint1(fgroups.fg0.cf);

    /* store subtraction result in reg file */
    bn_movr(x8, true, x13, false);
    next_view := prev_view[iter.index := w24];
    assert valid_wdr_view(wdrs, next_view, 4, NUM_WORDS);

    subb_inv_peri_lemma(next_view, new_carry,
        init_view, next_iter.buff, old_carry, iter.index);
}

procedure sub_to_reg(
    ghost init_view: seq(uint256),
    ghost init_iter: iter_t)
    returns (ghost curr_view: seq(uint256))

    requires
        fgroups.fg0.cf == false;

        valid_wdr_view(wdrs, init_view, 4, NUM_WORDS);
        
        iter_safe(init_iter, heap, x22);
        init_iter.index == 0;
        seq_len(init_iter.buff) == NUM_WORDS;

    reads
        x22; x30; w3; w31; flat; heap;

    modifies
        fgroups;
        x8; x12; x13; x16;
        wdrs; w24; w29; w30;

    ensures
        w3 == old(w3);
        w31 == old(w31);

        valid_wdr_view(wdrs, curr_view, 4, NUM_WORDS);

        to_nat(curr_view) == 
            to_nat(init_view) - to_nat(init_iter.buff) +
            bool_to_uint1(fgroups.fg0.cf) * pow_BASE(NUM_WORDS);
{
    /* load pointers to temp regs */
    li(x12, 30);
    li(x13, 24);
    addi(x16, x22, 0);
    li(x8, 4);

    ghost var initial_x16 := x16;

    curr_view := init_view;
    ghost var iter := init_iter;

    subb_inv_pre_lemma(curr_view, init_view, iter.buff);

    /* iterate over all limbs for conditional limb-wise subtraction */
    while (LoopImm(12))
        invariant
            x8 == 4 + iter.index;
            x12 == 30;
            x13 == 24;

            iter_inv(iter, heap, x16);
            iter.buff == init_iter.buff;
            iter.index + loop_ctr == NUM_WORDS;

            w3 == old(w3);
            w31 == old(w31);

            valid_wdr_view(wdrs, curr_view, 4, NUM_WORDS);

            seq_len(init_view) == NUM_WORDS;
            init_view[iter.index..] == wdrs[x8..4 + NUM_WORDS];

            subb_inv(curr_view, bool_to_uint1(fgroups.fg0.cf),
                init_view, iter.buff, iter.index);

        decreases loop_ctr;
    {
        curr_view, iter :=
            cond_sub_to_reg_inner(init_view, curr_view, iter);
    }

    subb_inv_post_lemma(curr_view, bool_to_uint1(fgroups.fg0.cf),
        init_view, iter.buff);
}

procedure sub_to_reg_copy(
    ghost init_view: seq(uint256),
    ghost init_iter: iter_t)
    returns (ghost curr_view: seq(uint256))

    requires
        valid_wdr_view(wdrs, init_view, 4, NUM_WORDS);

        iter_safe(init_iter, heap, x16);
        init_iter.index == 0;
        seq_len(init_iter.buff) == NUM_WORDS;
        w31 == 0;

    reads
        x16; flat; heap;
        w4; w5; w6; w7; w8; w9; w10; w11; w12; w13; w14; w15;

    modifies
        fgroups;
        x8; x9; x10; x11; x12;
        wdrs; w2; w3; w16; w17; w18; w19;
        w20; w21; w22; w23; w24; w25; w26; w27; w31;

    ensures
        w4 == old(w4);
        w5 == old(w5);
        w6 == old(w6);
        w7 == old(w7);
        w8 == old(w8);
        w9 == old(w9);
        w10 == old(w10);
        w11 == old(w11);
        w12 == old(w12);
        w13 == old(w13);
        w14 == old(w14);
        w15 == old(w15);
        w31 == 0;

        valid_wdr_view(wdrs, curr_view, 16, NUM_WORDS);

        to_nat(curr_view) ==
            to_nat(init_view) - to_nat(init_iter.buff) +
            bool_to_uint1(fgroups.fg0.cf) * pow_BASE(NUM_WORDS);

        (fgroups.fg0.cf == true <==>
            to_nat(init_view) < to_nat(init_iter.buff));
{
    comment("/**");
    comment(" * Subtracts the modulus M from A.");
    comment(" *");
    comment(" * Flags: After this subroutine, the C flag is set to 1 if the subtraction");
    comment(" * underflowed.");
    comment(" *");
    comment(" * This routine runs in variable time.");
    comment(" * @param[in]  x16: dmem pointer to first limb of modulus M");
    comment(" * @param[in]  [w4:w15]: operand A");
    comment(" * @param[in]  w31: all-zero");
    comment(" * @param[out] [w16:w27]: result");
    comment(" *");
    comment(" * clobbered registers: x8 to x12, w2, w3, w16 to w27");
    comment(" * clobbered Flag Groups: FG0");
    comment(" */");

    comment("/* Prepare temporary registers. */");
    li(x8, 4);
    li(x9, 2);
    li(x10, 3);
    li(x11, 16);

    comment("/* Copy pointer to modulus. */");
    addi(x12, x16, 0);

    comment("/* Clear flags. */");
    bn_add(w31, w31, w31, SFT_DFT, 0);

    comment("/* Subtract M from A. */");
    curr_view := wdrs[16..16+NUM_WORDS];
    ghost var iter := init_iter;
    subb_inv_pre_lemma(curr_view, init_view, iter.buff);
    while (LoopImm(12))
        invariant
            x8 == 4 + iter.index;
            x9 == 2;
            x10 == 3;
            x11 == 16 + iter.index;

            w31 == 0;

            iter_inv(iter, heap, x12);
            iter.buff == init_iter.buff;
            iter.index + loop_ctr == NUM_WORDS;

            /* input values are unmodified */
            w4 == old(w4);
            w5 == old(w5);
            w6 == old(w6);
            w7 == old(w7);
            w8 == old(w8);
            w9 == old(w9);
            w10 == old(w10);
            w11 == old(w11);
            w12 == old(w12);
            w13 == old(w13);
            w14 == old(w14);
            w15 == old(w15);

            /* input view (unmodified) */
            valid_wdr_view(wdrs, init_view, 4, NUM_WORDS);

            /* output view */
            valid_wdr_view(wdrs, curr_view, 16, NUM_WORDS);

            seq_len(init_view) == NUM_WORDS;

            subb_inv(curr_view, bool_to_uint1(fgroups.fg0.cf),
                init_view, iter.buff, iter.index);

        decreases loop_ctr;
    {
        comment("/* w2 <= A[i] */");
        bn_movr(x9, false, x8, true);
        assert w2 == init_view[iter.index];

        comment("/* w3 <= M[i] */");
        let next_iter := bn_lid_safe(x10, false, 0, x12, true, iter);
        assert w3 == iter.buff[iter.index];

        comment("/* w2 <= w2 - w3 */");
        let old_carry := bool_to_uint1(fgroups.fg0.cf);
        bn_subb(w2, w2, w3, SFT_DFT, 0);
        let new_carry := bool_to_uint1(fgroups.fg0.cf);

        comment("/* out[i] <= w2 */");
        bn_movr(x11, true, x9, false);
        curr_view := curr_view[iter.index := w2];
        assert valid_wdr_view(wdrs, curr_view, 16, NUM_WORDS);

        subb_inv_peri_lemma(curr_view, new_carry,
            init_view, next_iter.buff, old_carry, iter.index);
        iter := next_iter;
    }

    subb_inv_post_lemma(curr_view, bool_to_uint1(fgroups.fg0.cf),
        init_view, iter.buff);
}


#verbatim
}
#endverbatim
