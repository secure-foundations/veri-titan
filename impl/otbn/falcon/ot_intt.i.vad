include "ot_mq_arith.i.vad"

#verbatim

include "ot_mq_arith.i.dfy"

module ot_norm {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale

import opened DivMod

import opened integers
import opened bv256_op_s
import opened bv256_falcon_lemmas
import opened falcon_512_i

import opened pow2_s

import opened ot_mq_arith

type wbuff = seq<uint256>

#endverbatim

type wbuff: Type(0) := seq(uint256);

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;

function as_elems(s: wbuff): wbuff extern;

function rev_omega_inv_powers_mont_table(): wbuff extern;
function rev_mixed_powers_mont_table_lemma(t: pow2_t, d: pow2_t, j: nat): void extern;
function rev_omega_inv_powers_x_value(i: nat, d: pow2_t): (r: uint16) extern;

type iloop_view: Type(0) extern;
function operator(.hsize) (p :iloop_view): pow2_t extern;
function build_iloop_view(a: wbuff, d: pow2_t): iloop_view extern;
function inverse_lsize(v: iloop_view): pow2_t extern;

function block_size(c: pow2_t): pow2_t extern;

function pow2_t_cons(n: nat, exp: nat): pow2_t extern;
function inverse_j_loop_inv(a: wbuff, hcount: pow2_t, j: nat, u: nat, view: iloop_view): bool extern;
function inverse_j_loop_inv_pre_lemma(a: wbuff, hcount: pow2_t, view: iloop_view): void extern;
function inverse_j_loop_inv_post_lemma(a: wbuff, hcount: pow2_t, j: nat, u: nat, view: iloop_view): void extern;

function inverse_s_loop_inv(a: wbuff, d: pow2_t, j: nat, bi: nat, view: iloop_view): bool extern;
function inverse_s_loop_inv_pre_lemma(a: wbuff, d: pow2_t, j: nat, t: pow2_t, u: nat, view: iloop_view): void extern;
function inverse_s_loop_inv_post_lemma(a: wbuff, d: pow2_t, j: nat, u: nat, bi: nat, view: iloop_view): void extern;
function inverse_s_loop_index_lemma(a: wbuff, d: pow2_t, j: nat, s: nat, bi: nat, view: iloop_view): (gs: nat) extern;
function inverse_s_loop_update(a: wbuff, a': wbuff, d: pow2_t, j: nat, bi: nat, s: nat, e: nat, o: nat, view: iloop_view): bool extern;
function inverse_s_loop_inv_peri_lemma(a: wbuff, a': wbuff, d: pow2_t, j: nat, bi: nat, s: nat, e: nat, o: nat, view: iloop_view): void extern;

function inverse_ntt_eval_all(a: wbuff, coeffs: wbuff): bool extern;
function inverse_t_loop_inv(a: wbuff, d: pow2_t, c: wbuff): bool extern;
function inverse_t_loop_inv_pre_lemma(c: wbuff): void extern;
function inverse_t_loop_inv_post_lemma(a: wbuff, one: pow2_t, c: wbuff): void extern;

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function msb(x: uint256): uint1 extern;
function montmul(x: nat, y: nat): nat extern;

const R: nat extern;

function mqmul(x: nat, y: nat): nat extern;
function mqsub(x: nat, y: nat): nat extern;
function mqadd(x: nat, y: nat): nat extern;

procedure inverse_s_loop(
    ghost iter_a: iter_t,
    ghost gd: pow2_t,
    ghost bi: nat,
    ghost view: iloop_view)
    returns (ghost iter_a': iter_t)
{:frame false}
    lets
        d         @= x6;
        t         @= x7;
        j         @= x8;
        s         @= x9;
        u         @= x12;
        pd        @= x10;

        a_base    @= x4; 
        p_base    @= x11;

        ao_ptr    @= x13;
        ae_ptr    @= x14;

    requires
        d == gd.full;
        u == j * (2 * gd.full);
        s == (bi + u) * 32;

        x15 == 2;
        x16 == 0;

    requires
        w1 == 12289;
        w3 == mqmul(rev_omega_inv_powers_x_value(2 * j, gd), R);
        w5 == 12287;
        wmod == Q;

    requires
        elems_iter_inv(heap, iter_a, a_base, 0);
        inverse_s_loop_inv(iter_a.buff, gd, j, bi, view);
        bi < gd.full;

    ensures
        d == old(d);
        t == old(t);
        pd == old(pd);
        j == old(j);
        s == (bi + u + 1) * 32;
        u == old(u);
        a_base == old(a_base);
        p_base == old(p_base);

        x15 == 2;
        x16 == 0;

    ensures
        w1 == old(w1);
        w3 == old(w3);
        w5 == old(w5);
        wmod == Q;

    ensures
        elems_iter_inv(heap, iter_a', old(a_base), 0);
        iter_a'.base_ptr == iter_a.base_ptr;

    ensures
        heap == old(heap)[iter_a'.base_ptr := heap[iter_a'.base_ptr]];
    
    ensures
        inverse_s_loop_inv(iter_a'.buff, gd, j, bi+1, view);
{
    left_shift_5(ao_ptr, d);
    add(ae_ptr, s, a_base);
    add(ao_ptr, ae_ptr, ao_ptr);

    let gs := inverse_s_loop_index_lemma(iter_a.buff, gd, j, s, bi, view);
    let a_e := iter_a.buff[gs];
    let a_o := iter_a.buff[gs + d];

    iter_a' := bn_lid_safe(x15, false, 0, ao_ptr, false, iter_a.(index := gs + d));
    // assert w2 == a_o;
 
    bn_mov(w6, w3);
    montymul();
    assume (w4 == montmul(a_o, old(w3)));
    let x := w4;

    iter_a' := bn_lid_safe(x15, false, 0, ae_ptr, false, iter_a.(index := gs));
    // assert w2 == a_e;

    mq_sub(w0, w2, w4);
    let o := w0;

    iter_a' := bn_sid_safe(x16, false, 0, ao_ptr, false, iter_a'.(index := gs + d));

    mq_add(w0, w2, w4);
    let e := w0;


    iter_a' := bn_sid_safe(x16, false, 0, ae_ptr, false, iter_a'.(index := gs));

    inverse_s_loop_inv_peri_lemma(iter_a.buff, iter_a'.buff, gd, j, bi, gs, e, o, view);

    bn_mov(w3, w6);
    addi(s, s, 32);

    iter_a' := iter_a'.(index := 0);
}

procedure inverse_j_loop(
    ghost iter_a: iter_t,
    ghost iter_p: iter_t,
    ghost gt: pow2_t,
    ghost gd: pow2_t,
    ghost view: iloop_view)
    returns (ghost iter_a': iter_t)
{:frame false}

    lets
        d         @= x6;
        t         @= x7;
        j         @= x8;
        s         @= x9;
        u         @= x12;
        pd        @= x10;
        a_base    @= x4; 
        p_base    @= x11; 

    requires
        t == gt.full;
        d == gd.full;
        pd == 2 * d;

        x15 == 2;
        x16 == 0;

    requires
        w1 == 12289;
        w5 == 12287;
        wmod == Q;

    requires
        elems_iter_inv(heap, iter_a, a_base, 0);
        elems_iter_inv(heap, iter_p, p_base, 0);
        a_base != p_base;

    requires
        inverse_j_loop_inv(iter_a.buff, gd, j, u, view);
        iter_p.buff == rev_omega_inv_powers_mont_table();
        j < inverse_lsize(view).full;
        gt == inverse_lsize(view);

    ensures
        t == gt.full;
        d == gd.full;
        pd == old(pd);
        j == old(j);
        a_base == old(a_base);
        p_base == old(p_base);

        x15 == 2;
        x16 == 0;

    ensures
        w1 == 12289;
        w5 == 12287;
        wmod == Q;

    ensures
        elems_iter_inv(heap, iter_a', a_base, 0);
        elems_iter_inv(heap, iter_p, p_base, 0);
        iter_p.buff == rev_omega_inv_powers_mont_table();
        iter_a'.base_ptr == iter_a.base_ptr;

    ensures
        heap == old(heap)[a_base := heap[a_base]];

    ensures
        inverse_j_loop_inv(iter_a'.buff, gd, j + 1, u, view);
{
    add(x13, t, j);
    left_shift_5(x13, x13);
    add(x13, p_base, x13);

    addi(x14, x0, 3);
    inverse_s_loop_inv_pre_lemma(iter_a.buff, gd, j, gt, u, view);

    let _ := bn_lid_safe(x14, false, 0, x13, false, iter_p.(index := t + j));    
    assert w3 == iter_p.buff[t + j];

    ghost var bi :nat := 0;
    iter_a' := iter_a;

    left_shift_5(s, u);

    while (Loop(d))
        invariant
            d == old(d);
            t == gt.full;
            pd == 2 * d;
            d == gd.full;
            j == old(j);
            u == old(u);
            bi + loop_ctr == d;
            a_base == old(a_base);
            p_base == old(p_base);
            s == (bi + u) * 32;
            x15 == 2;
            x16 == 0;

        invariant
            w1 == 12289;
            w5 == 12287;
            wmod == Q;

        invariant
            w3 == mqmul(rev_omega_inv_powers_x_value(2 * j, gd), R);

        invariant
            elems_iter_inv(heap, iter_a', a_base, 0);
            iter_a'.base_ptr == a_base;

        invariant        
            heap == old(heap)[a_base := heap[a_base]];

        invariant
            inverse_s_loop_inv(iter_a'.buff, gd, j, bi, view);

        decreases
            loop_ctr;
    {
        iter_a' := inverse_s_loop(iter_a', gd, bi, view);
        bi := bi + 1;
    }

    inverse_s_loop_inv_post_lemma(iter_a'.buff, gd, j, u, bi, view);
    add(u, u, pd);
}

procedure fntt_t_loop(ghost iter_a: iter_t,
    ghost iter_p: iter_t,
    ghost gt: pow2_t,
    ghost gd: pow2_t,
    ghost coeffs: wbuff)
returns (ghost iter_a': iter_t)
    {:frame false}

    lets
        d         @= x6;
        t         @= x7;
        j         @= x8;
        s         @= x9;
        pd        @= x10;
        u         @= x12;

        a_base    @= x4; 
        p_base    @= x11;

    requires
        t == gt.full;
        pd == 2 * d;
        d == gd.full;
        
        x15 == 2;
        x16 == 0;

    requires
        w1 == 12289;
        w5 == 12287;
        wmod == Q;

    requires
        elems_iter_inv(heap, iter_a, a_base, 0);
        elems_iter_inv(heap, iter_p, p_base, 0);
        iter_a.base_ptr != iter_p.base_ptr;

    requires
        0 <= gd.exp < N.exp;
        gt == block_size(pow2_double(gd));
        inverse_t_loop_inv(iter_a.buff, pow2_double(gd), coeffs);
        iter_p.buff == rev_omega_inv_powers_mont_table();

    ensures
        t == old(t);
        d == old(d);
        x15 == 2;
        x16 == 0;
        pd == old(pd);
        a_base == old(a_base);

    ensures
        w1 == 12289;
        w5 == 12287;
        wmod == Q;

    ensures
        elems_iter_inv(heap, iter_a', a_base, 0);
        iter_a'.base_ptr == iter_a.base_ptr;
        elems_iter_inv(heap, iter_p, p_base, 0);
        heap == old(heap)[a_base := heap[a_base]];
    
    ensures
        inverse_t_loop_inv(iter_a'.buff, gd, coeffs);
{
    addi(j, x0, 0);
    addi(u, x0, 0);

    ghost var view := build_iloop_view(as_elems(coeffs), gd);

    iter_a' := iter_a;

    inverse_j_loop_inv_pre_lemma(iter_a'.buff, gd, view);
    sub(x13, t, j);
    let j_lc := t - j;

    while (Loop(x13))
        invariant
            t == gt.full;
            pd == 2 * d;
            d == gd.full;
            a_base == old(a_base);
            p_base == old(p_base);
            j + loop_ctr == j_lc;
            x15 == 2;
            x16 == 0;

        invariant
            w1 == 12289;
            w5 == 12287;
            wmod == Q;

        invariant
            elems_iter_inv(heap, iter_a', a_base, 0);
            elems_iter_inv(heap, iter_p, p_base, 0);
            iter_a'.base_ptr == iter_a.base_ptr;
            iter_a'.base_ptr != iter_p.base_ptr;

        invariant
            heap == old(heap)[a_base := heap[a_base]];

        invariant
            inverse_j_loop_inv(iter_a'.buff, gd, j, u, view);

        decreases
            loop_ctr;
    {
        iter_a' := inverse_j_loop(iter_a', iter_p, gt, gd, view);
        addi(j, j, 1);
    }

    inverse_j_loop_inv_post_lemma(iter_a'.buff, gd, j, u, view);
}

procedure fntt(
    ghost iter_a: iter_t,
    ghost iter_p: iter_t)
returns (ghost iter_a': iter_t)

{:noInline}
{:frame false}

    lets
        d         @= x6;
        t         @= x7;
        j         @= x8;
        s         @= x9;
        pd        @= x10; 

        a_base    @= x4; 
        p_base    @= x11; 

    requires 
        w1 == 12289;
        w5 == 12287;
        wmod == Q;

    requires
        elems_iter_inv(heap, iter_a, x4, 0);

    requires
        symbols?["rev_omega_inv_powers_mont_table"];
        elems_iter_inv(heap, iter_p, 
            symbols["rev_omega_inv_powers_mont_table"], 0);
        iter_p.buff == rev_omega_inv_powers_mont_table();

    requires
        iter_a.base_ptr != iter_p.base_ptr;

    ensures
        a_base == old(a_base);

    ensures
        w1 == 12289;
        w5 == 12287;
        wmod == Q;

    ensures
        elems_iter_inv(heap, iter_a', a_base, 0);
        iter_a'.base_ptr == iter_a.base_ptr;

    ensures
        heap == old(heap)[a_base := heap[a_base]];

    ensures
        inverse_ntt_eval_all(iter_a'.buff, iter_a.buff);
{
    iter_a' := iter_a;

    addi(d, x0, 512);
    addi(t, x0, 1);

    addi(x15, x0, 2);
    addi(x16, x0, 0);

    la(p_base, "rev_omega_inv_powers_mont_table");

    inverse_t_loop_inv_pre_lemma(iter_a.buff);
    let coeffs := iter_a.buff;

    ghost var gd := N;
    ghost var i :int := 9;
    ghost var gt := pow2(0);
    pow2_basics_lemma(gt);

    while (LoopImm(9))
        invariant
            t == gt.full;
            d == gd.full;
    
            x15 == 2;
            x16 == 0;

        invariant
            w1 == 12289;
            w5 == 12287;
            wmod == Q;

        invariant
            elems_iter_inv(heap, iter_a', a_base, 0);
            iter_a'.base_ptr == iter_a.base_ptr;
            elems_iter_inv(heap, iter_p, p_base, 0);

        invariant
            heap == old(heap)[a_base := heap[a_base]];

        invariant
            gd.exp == loop_ctr;
            0 <= gd.exp <= N.exp;
            gt == block_size(gd);
            inverse_t_loop_inv(iter_a'.buff, gd, coeffs);

        decreases
            loop_ctr;
    {
        addi(pd, d, 0);
        gd := half(d, gd);

        iter_a' := fntt_t_loop(iter_a', iter_p, gt, gd, coeffs);

        gt := double(t, gt);
        i := i - 1;
    }

    inverse_t_loop_inv_post_lemma(iter_a'.buff, gd, coeffs);
}

#verbatim
}
#endverbatim
