include "ot_norm.i.vad"
include "ot_fntt.i.vad"
include "ot_intt.i.vad"

#verbatim

include "ot_norm.i.dfy"
include "ot_fntt.i.dfy"
include "ot_intt.i.dfy"

module ot_falcon {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale

import opened DivMod

import opened integers
import opened bv256_op_s
import opened bv256_falcon_lemmas
import opened falcon_512_i
import opened ot_norm
import opened ot_fntt
import opened ot_intt

#endverbatim

type pow2_t: Type(0) extern;
function pow2(exp: int): pow2_t extern;
function operator(.full) (p :pow2_t): nat extern;
function operator(.exp) (p :pow2_t): nat extern;
function pow2_half(p: pow2_t): pow2_t extern;
function pow2_double(p: pow2_t): pow2_t extern;
function pow2_basics_lemma(p: pow2_t): void extern;

type wbuff: Type(0) := seq(uint256);

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function nelems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function as_elems(s: wbuff): wbuff extern;
function msb(x: uint256): uint1 extern;
function inverse_ntt_scaling_table(): wbuff extern;
function rev_omega_inv_powers_mont_table(): wbuff extern;
function rev_mixed_powers_mont_table(): wbuff extern;
function heap_b32_ptr_valid(heap: heap_t, base_ptr: nat, count: nat): bool extern;
function b32_seq(heap: heap_t, base_ptr: nat, count: nat): seq(uint32) extern;
function bit_rev_ftable_wf(table: seq(uint32)): bool extern;
function xor_clear_lemma(x: uint256, y: uint256): void extern;

procedure poly_mul(
    ghost iter_h: iter_t,
    ghost iter_tt: iter_t,
    ghost iter_t1: iter_t,
    ghost iter_t2: iter_t,
    ghost iter_p1: iter_t,
    ghost iter_p2: iter_t)

returns (ghost iter_tt': iter_t, ghost iter_h': iter_t)

{:frame false}

    requires
        w1 == Q;
        wmod == Q;

    requires
        elems_iter_inv(heap, iter_h, x4, 0);
        elems_iter_inv(heap, iter_tt, x5, 0);

    requires
        symbols?["bit_rev_table_512"];
        heap_b32_ptr_valid(heap, symbols["bit_rev_table_512"], 480);
        bit_rev_ftable_wf(b32_seq(heap, symbols["bit_rev_table_512"], 480));

    requires
        symbols?["scaling_factors"];
        elems_iter_inv(heap, iter_t2,
            symbols["scaling_factors"], 0);
        iter_t2.buff == inverse_ntt_scaling_table();

    requires
        symbols?["rev_omega_inv_powers_mont_table"];
        elems_iter_inv(heap, iter_p1,
            symbols["rev_omega_inv_powers_mont_table"], 0);
        iter_p1.buff == rev_omega_inv_powers_mont_table();

    requires
        symbols?["rev_mixed_powers_mont_table"];
        elems_iter_inv(heap, iter_p2,
            symbols["rev_mixed_powers_mont_table"], 0);
        iter_p2.buff == rev_mixed_powers_mont_table();

    requires
        iter_h.base_ptr != iter_tt.base_ptr;
        iter_h.base_ptr != iter_t1.base_ptr;
        iter_h.base_ptr != iter_t2.base_ptr;
        iter_h.base_ptr != iter_p1.base_ptr;
        iter_h.base_ptr != iter_p2.base_ptr;

        iter_tt.base_ptr != iter_t1.base_ptr;
        iter_tt.base_ptr != iter_t2.base_ptr;
        iter_tt.base_ptr != iter_p1.base_ptr;
        iter_tt.base_ptr != iter_p2.base_ptr;
{
    iter_tt' := iter_tt;
    iter_h' := iter_h;

    bn_subi(w5, w1, 2, 0);
    addi(x17, x4, 0);
    addi(x4, x5, 0);

    iter_tt' := fntt(iter_tt', iter_p2);
    addi(x5, x4, 0);

    addi(x4, x17, 0);
    iter_h' := fntt(iter_h', iter_p2);

    assert elems_iter_inv(heap, iter_tt', x5, 0);
    assert elems_iter_inv(heap, iter_h', x4, 0);

}

procedure ot_falcon(
    ghost iter_c0: iter_t,
    ghost iter_s2: iter_t,
    ghost iter_h: iter_t,
    ghost iter_tt: iter_t,
    ghost iter_t1: iter_t,
    ghost iter_t2: iter_t,
    ghost iter_p1: iter_t,
    ghost iter_p2: iter_t)

returns (ghost iter_tt': iter_t)

{:noInline}
{:frame false}

    requires
        wmod == Q;
        w1 == Q;

    requires
        elems_iter_inv(heap, iter_c0, x2, 0);
        nelems_iter_inv(heap, iter_s2, x3, 0);

        elems_iter_inv(heap, iter_h, x4, 0);
        elems_iter_inv(heap, iter_tt, x5, 0);

    requires
        symbols?["bit_rev_table_512"];
        heap_b32_ptr_valid(heap, symbols["bit_rev_table_512"], 480);
        bit_rev_ftable_wf(b32_seq(heap, symbols["bit_rev_table_512"], 480));

    requires
        symbols?["scaling_factors"];
        elems_iter_inv(heap, iter_t2,
            symbols["scaling_factors"], 0);
        iter_t2.buff == inverse_ntt_scaling_table();

    requires
        symbols?["rev_omega_inv_powers_mont_table"];
        elems_iter_inv(heap, iter_p1,
            symbols["rev_omega_inv_powers_mont_table"], 0);
        iter_p1.buff == rev_omega_inv_powers_mont_table();

    requires
        symbols?["rev_ntt512_mixed_powers_table"];
        elems_iter_inv(heap, iter_p2,
            symbols["rev_ntt512_mixed_powers_table"], 0);
        iter_p2.buff == rev_mixed_powers_mont_table();

    requires
        iter_h.base_ptr != iter_c0.base_ptr;
        iter_h.base_ptr != iter_s2.base_ptr;
        iter_h.base_ptr != iter_tt.base_ptr;
        iter_h.base_ptr != iter_t1.base_ptr;
        iter_h.base_ptr != iter_t2.base_ptr;
        iter_h.base_ptr != iter_p1.base_ptr;
        iter_h.base_ptr != iter_p2.base_ptr;

        iter_tt.base_ptr != iter_c0.base_ptr;
        iter_tt.base_ptr != iter_s2.base_ptr;
        iter_tt.base_ptr != iter_t1.base_ptr;
        iter_tt.base_ptr != iter_t2.base_ptr;
        iter_tt.base_ptr != iter_p1.base_ptr;
        iter_tt.base_ptr != iter_p2.base_ptr;
{
    xor_clear_lemma(w2, w2);
    bn_xor(w2, w2, w2, SFT_DFT, 0);
    // bn_addi(w1, w2, 12289, 0);
    iter_tt' := denorm(iter_s2, iter_tt);
    
}

    
// {:frame false}
//     lets

//     requires
//         elems_iter_inv(heap, iter_a, a_base, 0);
//         elems_iter_inv(heap, iter_p,
//             load_symbol(mem, "rev_mixed_powers_mont_table"), 0);
//     requires
//         iter_p.buff == rev_mixed_powers_mont_table();
//     requires
//         iter_a.base_ptr != iter_p.base_ptr;
    
//     // ensures
//     //     elems_iter_inv(heap, iter_a', a_base, 0);
//     //     iter_a'.base_ptr == iter_a.base_ptr;

//     // ensures
//     //     heap == old(mem).heap[a_base := heap[a_base]];

//     ensures
//         forward_ntt_eval_all(iter_a'.buff, iter_a.buff);
// {
//     mov_w_imm(512, d);
//     mov_w_imm(1, t);
//     lw_symbol("rev_mixed_powers_mont_table", p_base);

//     forward_t_loop_inv_pre_lemma(iter_a.buff);
//     let coeffs := iter_a.buff;

//     ghost var gd := N;
//     ghost var i :int := 9;
//     ghost var gt := pow2(0);
//     pow2_basics_lemma(gt);

//     while (t < 512)
//         invariant
//             sp == sp0;
//             t == gt.full;
//             d == gd.full;
//             a_base == old(a_base);

//         invariant
//             elems_iter_inv(heap, iter_a', a_base, 0);
//             elems_iter_inv(heap, iter_p, p_base, 0);
//             iter_a'.base_ptr == a_base;
//             iter_a'.base_ptr != p_base;

//         invariant
//             heap == mem0.heap[a_base := heap[a_base]];

//         invariant
//             gd.exp == i;
//             0 <= gd.exp <= N.exp;
//             gt == block_size(gd);
//             forward_t_loop_inv(iter_a'.buff, gd, coeffs);

//         decreases
//             i;
//     {
//         mov_w(d, pd);
//         gd := half(d, gd);

//         iter_a' := fntt_t_loop(iter_a', iter_p, gt, gd, coeffs);

//         gt := double(t, gt);
//         i := i - 1;
//     }

//     forward_t_loop_inv_post_lemma(iter_a'.buff, gd, coeffs);

//     popm_w(7, r10);
//     iter_a' := iter_a'.(index := 0);
//     assert frames == old(frames);
// }

#verbatim
}
#endverbatim
