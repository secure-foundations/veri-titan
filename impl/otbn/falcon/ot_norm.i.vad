include "ot_mq_arith.i.vad"

#verbatim

include "ot_mq_arith.i.dfy"

module ot_norm {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale

import opened DivMod

import opened integers
import opened bv256_op_s
import opened bv256_falcon_lemmas
import opened falcon_512_i

#endverbatim

type pow2_t: Type(0) extern;
function pow2(exp: int): pow2_t extern;
function operator(.full) (p :pow2_t): nat extern;
function operator(.exp) (p :pow2_t): nat extern;
function pow2_half(p: pow2_t): pow2_t extern;
function pow2_double(p: pow2_t): pow2_t extern;
function pow2_basics_lemma(p: pow2_t): void extern;

const N: pow2_t extern; 

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function nelems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function denorm_inv(nv: seq(uint256), dnv: seq(uint256), i: nat): bool extern;
function denorm_inv_peri_lemma(nv: seq(uint256), dnv: seq(uint256), i: nat, a: uint256, b: uint256): void extern;
function msb(x: uint256): uint1 extern;

procedure denormolize(
    ghost iter_s2: iter_t,
    ghost iter_tt: iter_t)
returns (ghost iter_tt': iter_t)
{:frame false}

    requires
        // Q    @= w1;
        w1 == Q;
        w2 == 0;

        nelems_iter_inv(heap, iter_s2, x2, 0);
        elems_iter_inv(heap, iter_tt, x3, 0);
        iter_s2.base_ptr != iter_tt.base_ptr;
{
    ghost var iter_s2' := iter_s2;
    iter_tt' := iter_tt;
    ghost var i: nat := 0;
    li(x4, 3);
    // li(x5, 4);

    // iter_s2' := bn_lid_safe(x4, false, 0, x2, true, iter_s2');
    reveal valid_elems;

    while (LoopImm(512))
        invariant
            x4 == 3;
            // x5 == 4;

        invariant
            w1 == Q;
            w2 == 0;

        invariant
            nelems_iter_inv(heap, iter_s2', x2, i);
            iter_s2'.base_ptr == iter_s2.base_ptr;
            elems_iter_inv(heap, iter_tt', x3, i);
            iter_tt'.base_ptr == iter_tt.base_ptr;

        invariant
            0 <= i <= 512;
            loop_ctr + i == 512;

        invariant
            heap == old(heap)
                [iter_tt'.base_ptr := heap[iter_tt'.base_ptr]];

        invariant
            denorm_inv(iter_s2'.buff, iter_tt'.buff, i);

        decreases
            loop_ctr;
    {
        iter_s2' := bn_lid_safe(x4, false, 0, x2, true, iter_s2');
        let nv := iter_s2'.buff[i];
        // assert w3 == nv; 
        bn_add(w4, w2, w3, SFT_DFT, 0);
        bn_add(w4, w1, w3, SFT_DFT, 1);
        bn_sel(w3, w4, w3, 0, 1);

        iter_tt' := bn_sid_safe(x4, false, 0, x3, true, iter_tt');
        i := i + 1;
    }
}


#verbatim
}
#endverbatim
