include "ot_mq_arith.i.vad"

#verbatim

include "ot_mq_arith.i.dfy"

module ot_norm {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale

import opened DivMod

import opened integers
import opened bv256_op_s
import opened bv256_falcon_lemmas
import opened falcon_512_i

import opened ot_mq_arith

#endverbatim

const N: pow2_t extern; 

function elems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function nelems_iter_inv(heap: heap_t, iter: iter_t, address: int, index: int): bool extern;
function denorm_inv(nv: seq(uint256), dnv: seq(uint256), i: nat): bool extern;
function denorm_inv_peri_lemma(nv: seq(uint256), dnv: seq(uint256), i: nat, a: uint256, b: uint256): void extern;
function msb(x: uint256): uint1 extern;

procedure denormolize(
    ghost iter_s2: iter_t,
    ghost iter_tt: iter_t)
returns (ghost iter_tt': iter_t)

    requires
        w1 == Q;

        nelems_iter_inv(heap, iter_s2, x3, 0);
        elems_iter_inv(heap, iter_tt, x5, 0);
        iter_s2.base_ptr != iter_tt.base_ptr;

    modifies
        flat; heap; fgroups;
        x3; x5; x6; x7; x8;
        w2; w3; w4; wdrs; 

    reads
        w1;

    ensures
        x3 == old(x3);
        x5 == old(x5);

    ensures
        w1 == old(w1);

    ensures
        nelems_iter_inv(heap, iter_s2, x3, 0);
        elems_iter_inv(heap, iter_tt', x5, 0);
        iter_tt'.base_ptr == iter_tt.base_ptr;

    ensures
        heap == old(heap)
            [iter_tt'.base_ptr := heap[iter_tt'.base_ptr]];

    ensures
        denorm_inv(iter_s2.buff, iter_tt'.buff, N.full);
{
    xor_clear_lemma(w2, w2);
    bn_xor(w2, w2, w2, SFT_DFT, 0);

    ghost var iter_s2' := iter_s2;
    iter_tt' := iter_tt;
    ghost var i: nat := 0;
    addi(x7, x3, 0);
    addi(x8, x5, 0);
    li(x6, 3);

    reveal valid_elems;

    while (LoopImm(512))
        invariant
            x6 == 3;
            x7 == iter_s2'.base_ptr;
            x8 == iter_tt'.base_ptr;

        invariant
            w1 == Q;
            w2 == 0;

        invariant
            nelems_iter_inv(heap, iter_s2', x3, i);
            iter_s2'.base_ptr == iter_s2.base_ptr;
            elems_iter_inv(heap, iter_tt', x5, i);
            iter_tt'.base_ptr == iter_tt.base_ptr;

        invariant
            0 <= i <= 512;
            loop_ctr + i == 512;

        invariant
            heap == old(heap)
                [iter_tt'.base_ptr := heap[iter_tt'.base_ptr]];

        invariant
            denorm_inv(iter_s2'.buff, iter_tt'.buff, i);

        decreases
            loop_ctr;
    {
        iter_s2' := bn_lid_safe(x6, false, 0, x3, true, iter_s2');
        let nv := iter_s2'.buff[i];
        // assert w3 == nv; 
        bn_add(w4, w2, w3, SFT_DFT, 0);
        bn_add(w4, w1, w3, SFT_DFT, 1);
        bn_sel(w3, w4, w3, 0, 1);

        iter_tt' := bn_sid_safe(x6, false, 0, x5, true, iter_tt');
        i := i + 1;
    }

    iter_s2' := iter_s2'.(index := 0);
    iter_tt' := iter_tt'.(index := 0);

    addi(x3, x7, 0);
    addi(x5, x8, 0);
}

function norm_inv(outputs: seq(uint256), inputs: seq(uint256), i: nat): bool extern;
function norm_pre_lemma(inputs: seq(uint256)): void extern;
function iter_inv(iter: iter_t, heap: heap_t, address: int): bool extern;
function norm_peri_lemma(outputs: seq(uint256), inputs: seq(uint256), i: nat, w: uint16, flags: flags_t, diff: uint16, mask: uint16, rst: uint16): void extern;
function norm_post_lemma(outputs: seq(uint256), inputs: seq(uint256)): void extern;
function l2norm_squared(s1: seq(uint256), s2: seq(uint256), i: nat): nat extern;
function otbn_qmul(x: uint256, qx: uint2, y: uint256, qy: uint2): nat extern;

procedure normalize(
    ghost iter_tt: iter_t)
returns (ghost iter_tt': iter_t)
{:frame false}

    requires
        w1 == Q;
        w4 == Q/2;

    requires
        elems_iter_inv(heap, iter_tt, x4, 0);

    ensures
        x3 == old(x3);

    ensures
        nelems_iter_inv(heap, iter_tt', x4, 0);
        iter_tt'.base_ptr == iter_tt.base_ptr;
   
    ensures
        heap == old(heap)
            [iter_tt'.base_ptr := heap[iter_tt'.base_ptr]];

    ensures
        norm_inv(iter_tt'.buff, iter_tt.buff, 512);
{
    addi(x5, x4, 0);
    bn_clear(w2);

    iter_tt' := iter_tt;
    li(x6, 3);

    ghost var i :nat := 0;
    reveal norm_inv;
    reveal valid_elems;

    while (LoopImm(512))
        invariant
            x3 == old(x3);
            x5 == old(x4);
            x6 == 3;

        invariant
            w1 == Q;
            w2 == 0;
            w4 == Q/2;

        invariant
            iter_inv(iter_tt', heap, x4);
            iter_tt'.base_ptr == iter_tt.base_ptr;
            seq_len(iter_tt'.buff) == 512;
            iter_tt'.index == i;

        invariant
            heap == old(heap)
            [iter_tt'.base_ptr := heap[iter_tt'.base_ptr]];

        invariant
            norm_inv(iter_tt'.buff, iter_tt.buff, i);

        invariant
            iter_tt'.index + loop_ctr == 512;

        decreases
            loop_ctr;
    {
        iter_tt' := bn_lid_safe(x6, false, 0, x4, false, iter_tt');

        let vv := w3;

        bn_sub(w5, w4, w3, SFT_DFT, 0);
        bn_sub(w5, w3, w1, SFT_DFT, 1);
        bn_sel(w3, w5, w3, 0, 0);

        iter_tt' := bn_sid_safe(x6, false, 0, x4, true, iter_tt');

        i := i + 1;
    }
    addi(x4,x5, 0);
    iter_tt' := iter_tt'.(index := 0);
}

function accumlate_lemma(a: seq(uint256), i: nat): nat extern;
function otbn_hwb(x: uint256, v: uint256, lower: bool): uint256 extern;

procedure is_short(
    ghost iter_a: iter_t,
    ghost iter_b: iter_t)
{:frame false}
    lets 
        x    @= w3; 
        y    @= w4;

    requires
        nelems_iter_inv(heap, iter_a, x4, 0);
        nelems_iter_inv(heap, iter_b, x3, 0);

    ensures
        fgroups.fg0.cf
            <==>
        l2norm_squared(iter_a.buff, iter_b.buff, 512) < 0x29845d6;
{
    ghost var iter_a' := iter_a;
    ghost var iter_b' := iter_b;

    ghost var i :nat := 0;

    addi(x6, x0, 3);
    addi(x7, x0, 4);

    bn_clear(x);
    bn_wsrw(3, x);

    while (LoopImm(512))
        invariant
            x6 == 3;
            x7 == 4;

        invariant
            nelems_iter_inv(heap, iter_a', x4, i);
            iter_a'.base_ptr == iter_a.base_ptr;
            nelems_iter_inv(heap, iter_b', x3, i);
            iter_b'.base_ptr == iter_b.base_ptr;

        invariant
            wacc <= 8589934592 * i;
            wacc == l2norm_squared(iter_a.buff, iter_b.buff, i);

        invariant
            heap == old(heap);

        invariant
            loop_ctr + i == 512;

        decreases
            loop_ctr;
    {
        iter_a' := bn_lid_safe(x6, false, 0, x4, true, iter_a');
        iter_b' := bn_lid_safe(x7, false, 0, x3, true, iter_b');

        let pa := accumlate_lemma(iter_a.buff, i);
        let pb := accumlate_lemma(iter_b.buff, i);
       
        bn_mulqacc_safe(x, 0, x, 0, 0);
        bn_mulqacc_safe(y, 0, y, 0, 0);

        i := i + 1;
    }

    bn_wsrr(x, 3);

    assert x == l2norm_squared(iter_a.buff, iter_b.buff, 512);

    bn_clear(y);
    bn_addi(y, y, 81, 0);
    assume otbn_qmul(81, 0, 81, 0) == 6561;

    bn_mulqacc_z(y, 0, y, 0, 0);
    bn_wsrr(y, 3);
    assert y == 6561;
    bn_addi(y, y, 37, 0);

    bn_mulqacc_z(y, 0, y, 0, 0);

    assume otbn_qmul(6598, 0, 6598, 0) == 43533604;

    bn_wsrr(y, 3);
    assert y == 43533604;

    bn_addi(y, y, 178, 0);

    assert y == 0x29845d6;

    bn_sub(x, x, y, SFT_DFT, 0);
}


#verbatim
}
#endverbatim
