include "../../../spec/arch/otbn/decls.i.vad"

#verbatim

include "../../../spec/arch/otbn/decls.i.dfy"
include "../../../../glue/otbn/falcon/bv256_falcon_lemmas.i.dfy"

module ot_mq_arith {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale

import opened integers
import opened bv256_op_s
import opened bv256_falcon_lemmas
import opened DivMod
import opened falcon_512_i

import opened pow2_s

#endverbatim

type pow2_t: Type(0) extern;
function pow2(exp: int): pow2_t extern;
function operator(.full) (p :pow2_t): nat extern;
function operator(.exp) (p :pow2_t): nat extern;
function pow2_half(p: pow2_t): pow2_t extern;
function pow2_double(p: pow2_t): pow2_t extern;
function pow2_basics_lemma(p: pow2_t): void extern;

const Q: nat extern;
const N: pow2_t extern; 

function mod(a: int, n: int): int extern;
function addm_correct_lemma(x: uint256, y: uint256, mod: uint256): void extern;
function subm_correct_lemma(x: uint256, y: uint256, mod: uint256): void extern;
function xor_clear_lemma(x: uint256, y: uint256): void extern;
function SFT(left: bool, bytes: uint5): shift_t extern;
function lemma_small_mulqacc(x: uint256, y: uint256, r: uint256, old_wacc: uint256, old_flags: flags_t): void extern;
function lemma_elem_prod_bound(x: uint256, y: uint256, r: uint256): void extern;
function lemma_montymul_correct(x: uint256, y: uint256, prod: uint256, sum: uint256, shifted: uint256, diff1: uint256, flags: flags_t, diff2: uint256): void extern;

function rs1_lemma(x: uint32): void extern;
function ls1_lemma(a: uint32): void extern;
function pow2_increases_lemma(n: pow2_t, n': pow2_t): void extern;

procedure mq_add(inout dst: reg256, in src1: reg256, in src2: reg256)
    requires
        src1 < wmod;
        src2 < wmod;
        wmod == Q;
    reads
        wmod;
    ensures
      dst == mod(old(src1) + old(src2), old(wmod));
{
    ghost var x := src1;
    ghost var y := src2;

    bn_addm(dst, src1, src2);
    addm_correct_lemma(x, y, wmod);
}
    
procedure mq_sub(inout dst: reg256, in src1: reg256, in src2: reg256)
    requires
        src1 < wmod;
        src2 < wmod;
        wmod == Q;
    reads
        wmod;
    ensures
      dst == mod(old(src1) - old(src2), old(wmod));
{
    ghost var x := src1;
    ghost var y := src2;

    bn_subm(dst, src1, src2);
    subm_correct_lemma(x, y, wmod);
}

procedure bn_clear(inout dst: reg256)
    modifies fgroups;
    ensures dst == 0;
{
    xor_clear_lemma(dst, dst);
    bn_xor(dst, dst, dst, SFT_DFT, 0);
}

procedure montymul()
    lets 
      Q    @= w1;
      x    @= w2;
      y    @= w3;
      r    @= w4;
      Q0I  @= w5;
    
    requires
        Q == 12289;
        Q0I == 12287;
        x < 12289;
        y < 12289;
    reads
        Q; Q0I;
    modifies
        x; y; r; wacc;
        fgroups;
    ensures
        IsModEquivalent(r * 4091, old(x * y), 12289);
{
    bn_clear(r);  // r <- 0

    ghost var old_wacc := wacc;
    ghost var old_flags := get_fgroup(fgroups, 0);
    bn_mulqacc_so_zero(r, true, x, 0, y, 0, 0, 0);   // r <- x * y
    lemma_small_mulqacc(x, y, r, old_wacc, old_flags);
    assert r == x * y;
    lemma_elem_prod_bound(x, y, r);

    old_wacc := wacc;
    old_flags := get_fgroup(fgroups, 0);
    bn_clear(y);  // y <- 0   Use y as a temporary
    bn_mulqacc_so_zero(y, true, Q, 0, Q0I, 0, 0, 0); // y <- Q * Q0I
    lemma_small_mulqacc(Q, Q0I, y, old_wacc, old_flags);
    assert y == Q * Q0I;

    old_wacc := wacc;
    old_flags := get_fgroup(fgroups, 0);
    let QQ0I := y;
    bn_clear(x);  // x <- 0   Use x as a temporary
    bn_mulqacc_so_zero(x, true, r, 0, y, 0, 0, 0);   // x <- x * y * Q * Q0I
    lemma_small_mulqacc(r, QQ0I, x, old_wacc, old_flags);
    assert x == (old(x) * old(y)) * (Q * Q0I);
    let prod := x;

    bn_add(r, x, r, SFT_DFT, 0);       // r <- x * y * Q * Q0I + x*y
    let sum := r;
    bn_clear(y);                       // y <- 0
    bn_add(r, y, r, SFT(false, 2), 0); // r <- (x * y * Q * Q0I + x*y) >> 16
    let shifted := r;
    bn_sub(r, r, Q, SFT_DFT, 0);       // r -= Q
    let diff := r;
    let flags := get_fgroup(fgroups, 0);
    bn_sel(y, Q, y, 0, 0);             // y <- if carry then Q else 0
    bn_add(r, r, y, SFT_DFT, 0);       // r += y 

    lemma_montymul_correct(old(x), old(y), prod, sum, shifted, diff, flags, r);
}

procedure half(inout dst: reg32, ghost p: pow2_t)
    returns (ghost p': pow2_t)
    requires
        dst == p.full;
        (512 >= p.full >= 2) || (9 >= p.exp >= 1);
    ensures
        dst == old(dst) / 2;
        dst == p'.full;
        p' == pow2_half(p);
{
    rs1_lemma(dst);
    pow2_increases_lemma(p, N);
    srli(dst, dst, 1);
    p' := pow2_half(p);
}

procedure double(inout dst: reg32, ghost p: pow2_t)
    returns (ghost p': pow2_t)
    requires
        dst == p.full;
        (512 >= p.full >= 1) || (9 >= p.exp >= 0);
    ensures
        dst == old(dst) * 2;
        dst == p'.full;
        p' == pow2_double(p);
{
    add(dst, dst, dst);
    pow2_increases_lemma(p, N);
    p' := pow2_double(p);
}

procedure left_shift_4(inout dst: reg32, in src: reg32)
    ensures old(src) < 0x10000000 ==> dst == old(src) * 16;
{
    slli(dst, src, 4);
    assume false;
}

procedure left_shift_5(inout dst: reg32, in src: reg32)
    ensures old(src) < 0x8000000 ==> dst == old(src) * 32;
{
    slli(dst, src, 5);
    assume false;
}



#verbatim
}
#endverbatim
